<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hulu&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hulu&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hulu&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hulu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hulu&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.2.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-生产力工具" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/20/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/">快捷键系列</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2020/10/20/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2020-10-19T16:00:00.000Z" itemprop="datePublished">2020-10-20</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常用工具快捷键"><a href="#常用工具快捷键" class="headerlink" title="常用工具快捷键"></a>常用工具快捷键</h1><h2 id="ITerm"><a href="#ITerm" class="headerlink" title="ITerm"></a>ITerm</h2><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>command 族</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">command + t          新标签</span><br><span class="line">command + w          关闭标签</span><br><span class="line">command + num        切换到指定标签</span><br><span class="line">command + f          查找</span><br><span class="line">command + enter      切换全屏</span><br><span class="line">command + d          垂直分屏</span><br><span class="line">command + shift + d  水平分屏</span><br><span class="line">command + option + 方向键      切换分屏</span><br><span class="line">command + shift + h         查看剪贴板历史</span><br><span class="line">command + ;             查看命令历史 </span><br><span class="line">command + r               清除屏幕</span><br></pre></td></tr></table></figure>

<p>control 族</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">control + u         删除当前行</span><br><span class="line">control + a         跳到当前行头</span><br><span class="line">control + e         跳到当前行末</span><br><span class="line">control + f         向前移动光标</span><br><span class="line">control + b         向后移动光标</span><br><span class="line">control + p         前一条指令</span><br><span class="line">control + n         后一条指令</span><br><span class="line">control + d         删除光标处文字</span><br><span class="line">control + w         删除前一个单词 </span><br><span class="line">control + h         删除光标之前内容</span><br><span class="line">control + k         删除光标之后内容</span><br></pre></td></tr></table></figure>

<h2 id="Vim-常用快捷键"><a href="#Vim-常用快捷键" class="headerlink" title="Vim 常用快捷键"></a>Vim 常用快捷键</h2><p>命令行中的大杀器,掌握快捷键就是掌握效率</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般模式</span></span><br><span class="line">h,j,k,l 或者上下左右方向键         控制方向</span><br><span class="line">control + f                     向下翻页</span><br><span class="line">control + b                     向上翻页</span><br><span class="line"><span class="number">0</span>                               移动到本行最前</span><br><span class="line">shift + <span class="number">4</span>                       移动到本行最末</span><br><span class="line">shift + g                       移动到最后一行</span><br><span class="line">gg                              移动到第一行</span><br><span class="line">number + g                      移动到指定行</span><br><span class="line">number + enter                  往下移动n行</span><br><span class="line">w                               往后移动一个单词</span><br><span class="line">b                               往前移动一个单词</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相关字符串</span></span><br><span class="line">/word                           向下查找word</span><br><span class="line">?word                           向上查找word</span><br><span class="line">n                               重复前一个搜索动作</span><br><span class="line"><span class="type">N</span>                               逆向重复前一个搜索动作</span><br><span class="line">:n1,n2s/word1/word2/g           替换</span><br><span class="line">:<span class="number">1</span>,$s/word1/word2/g             从头到位替换word1</span><br><span class="line">:<span class="number">1</span>,$s/word1/word2/gc            替换需要comfirm</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">x                               向后删除一个字符</span><br><span class="line"><span class="type">X</span> 和 backspace                   向前删除一个字符</span><br><span class="line">number + x                      连续向后删除n个字符</span><br><span class="line">dd                              删除所在行</span><br><span class="line">number + dd                     删除包括所在行以下的n行</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制</span></span><br><span class="line">yy                              复制所在行</span><br><span class="line">number + yy                     复制所在行以下n行</span><br><span class="line">p                               粘贴复制的内容到所在行的下一行</span><br><span class="line"><span class="type">P</span>                               粘贴复制内容到所在行的上一行</span><br><span class="line"></span><br><span class="line"><span class="comment">//上一步下一步</span></span><br><span class="line">u                               复原前一个动作</span><br><span class="line">control + r                     执行前一个动作</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件读写</span></span><br><span class="line">:w                              保存文件</span><br><span class="line">:w!                             强制文件保存</span><br><span class="line">:q                  </span><br><span class="line">:q!</span><br><span class="line">:wq</span><br><span class="line"><span class="type">ZZ</span></span><br><span class="line">:w filename2                    另存为</span><br><span class="line">:n1,n2 w filename2              将n1,n2</span><br><span class="line">:r filename2                    将filename2中的文件读取到当前行的下一行</span><br><span class="line"> </span><br><span class="line"> :<span class="keyword">set</span> nu                        显示代码行</span><br><span class="line"> :<span class="keyword">set</span> nonu                      取消显示代码行</span><br></pre></td></tr></table></figure>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-iOS锁" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/09/iOS%E9%94%81/">iOS锁小记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2020/07/09/iOS%E9%94%81/" class="article-date">
  <time datetime="2020-07-08T16:00:00.000Z" itemprop="datePublished">2020-07-09</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS-锁"><a href="#iOS-锁" class="headerlink" title="iOS 锁"></a>iOS 锁</h1><h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>锁的本质是一种操作系统资源，是用来控制资源获取的方式。获得锁就是获得了资源的访问，失去锁就是失去了资源的访问。加锁的区域相当于结界，锁就是钥匙。</p>
<h2 id="为什么要锁"><a href="#为什么要锁" class="headerlink" title="为什么要锁"></a>为什么要锁</h2><p>计算机中关于线程安全方面最主要考虑的因素是不同的线程同一时间修改同一数据引起的。比如有一个int值为10.现在有5个线程分别想修改它为1，2，3，4，5那么最后这个int会被改成什么是不确定的。这样我们就失去了对这个数据的控制。所以我们谈线程安全最主要的目的就是让我们的输出可控。那么如何做到可控呢？就是保证从数据开始修改直到修改结束都不能被打扰。锁的用途便在这里。</p>
<h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>如果让我们保证数据从开始修改到修改结束都不能被打扰，只能被一个线程修改。那么其他线程只能等，怎么等是关键。<br>举个通俗的例子，约会等人的时候，有的人会走来走去踱步，反复看手机，确认时间。还有的人就坐在那里小憩，淡定安逸。</p>
<ol>
<li>一直走来走去反复看手机确认时间的人类似<strong>自旋锁</strong>。在还没获得资源的时候，一直循环是否锁已经被释放，可以去获得资源了。优点就是快，肯定比睡着等的人能快点看到约会对象。但是就是耗费能量，毕竟一直在循环着。这样忙等待的线程还有一个问题就是线程还是可以做别的事情，如果线程再上一把锁，那就有可能造成死锁了。</li>
<li>确认资源还不能活去就去睡的类似<strong>互斥锁</strong>。互斥锁会将线程处于等待的位置，让CPU帮别的，一旦资源的锁释放了，线程会被唤醒去调用资源。</li>
<li><strong>读写锁</strong>从线程的状态来看算是一种互斥锁。但因为不控制读取，控制写，也降低了使用成本。</li>
<li><strong>递归锁</strong>允许同一个线程反复加锁。非递归锁反复在一个线程上加会造成死锁。</li>
<li><strong>信号量</strong>gcd中信号量和锁有些区别，信号量可以控制获取资源的线程数。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>线程因为竞争资源而陷入到永久的等待状态，若无外力作用，无法解开。</p>
<h2 id="iOS中用到的锁"><a href="#iOS中用到的锁" class="headerlink" title="iOS中用到的锁"></a>iOS中用到的锁</h2><h4 id="Dispatch-semaphore"><a href="#Dispatch-semaphore" class="headerlink" title="Dispatch semaphore"></a>Dispatch semaphore</h4><p>gcd的信号量 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)semaphoreMethod &#123;</span><br><span class="line">    dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">         dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">             dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">             [[Seller shared]sellToCustoms];</span><br><span class="line">             dispatch_semaphore_signal(semaphore);</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch sync"></a>dispatch sync</h4><p>创建一个串行队列，在串行队列中添加任务，任务按照指定的顺序输出。不会出现抢占资源的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;hz&quot;, NULL);</span><br><span class="line"> for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        [[Seller shared]sellToCustoms];</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatch-Barrier"><a href="#Dispatch-Barrier" class="headerlink" title="Dispatch Barrier"></a>Dispatch Barrier</h4><p>作为阻塞线程的一种方法，利用<code>dispatch_barrier_sync</code>可以达到控制资源的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)barrierMethod &#123;</span><br><span class="line">      for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">          dispatch_barrier_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">              [[Seller shared]sellToCustoms];</span><br><span class="line">          &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized实际上是对pthread_metux递归锁的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)synchronizedMethod &#123;</span><br><span class="line">     for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">          dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">              @synchronized ([self class]) &#123;</span><br><span class="line">                  [[Seller shared]sellToCustoms];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="un-fair-lock"><a href="#un-fair-lock" class="headerlink" title="un_fair_lock"></a>un_fair_lock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)unfairLockMethod &#123;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">       dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">           os_unfair_lock_lock(&amp;self-&gt;_unfairLock);</span><br><span class="line">           [[Seller shared]sellToCustoms];</span><br><span class="line">           os_unfair_lock_unlock(&amp;self-&gt;_unfairLock);</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)nslockMethod &#123;</span><br><span class="line">&#x2F;&#x2F;    NSLock *lock &#x3D; [[NSLock alloc]init];</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">          dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">              [self.nslock lock];</span><br><span class="line">              [[Seller shared]sellToCustoms];</span><br><span class="line">              [self.nslock unlock];</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)pthreadMutexMethod &#123;</span><br><span class="line"></span><br><span class="line">    static pthread_mutex_t lock;</span><br><span class="line">    pthread_mutex_init(&amp;lock, NULL);</span><br><span class="line">    for(int i &#x3D; 0;i&lt;10;i++) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;lock);</span><br><span class="line">            [[Seller shared]sellToCustoms];</span><br><span class="line">            pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)conditionMethod &#123;</span><br><span class="line">    NSCondition *condition &#x3D; [[NSCondition alloc]init];</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            [condition lock];</span><br><span class="line">            [[Seller shared]sellToCustoms];</span><br><span class="line">            [condition unlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>锁的由来是因为多线程，因为多线程能做到不同的线程同时取获取一个资源，对这个资源进行修改。这样数据就不可控了，所以才有线程安全这样的命题，也才有了锁。</li>
<li>锁是一种系统资源，让高层的应用在多线程下，安全的控制资源的分配。</li>
<li>锁有一些基本的操作,<code>lock</code> <code>unlock</code> 。在获取资源之前加锁，在获取资源之后解锁，产生一个临界区，区域中的操作会根据系统的分配来进行操作。同时也有<code>wait</code>，<code>signal</code>操作。<code>wait</code>类似于<code>lock</code>，<code>signal</code>类似<code>unlock</code></li>
<li>锁根据对线程的操作来分，有<strong>互斥锁</strong>和<strong>自旋锁</strong>。加互斥锁的线程会让线程挂起等待系统调度获得锁。而自旋锁会让线程处于busy-waiting的状态，线程不断的循环看是否获得了锁。</li>
<li>比较底层的自旋锁<code>OSSpinLock</code>,但是因为自旋锁的忙等待，容易产生死锁的问题。还是慎用为好。</li>
<li>互斥锁就比较多了，底层有<code>pthread_metux_t</code>,然后又有<code>NSLock</code>，<code>NSRecursiveLock</code>，<code>NSCondition</code>等。</li>
<li>gcd中有几种方式能做到锁的效果。首先是信号量，我觉得信号量是一种高级锁，因为可以设置有限资源的数量，而不是给若干个资源加上若干个锁。<code>dispatch_barrier_sync</code>栅栏方法可以做到不同线程按顺序访问枷锁资源。当然也可以gcd创建串行队列，然后同步添加方法。</li>
<li><strong>递归锁</strong>允许同一个线程反复加锁。一般的锁适用于不同线程之间，强行加在同一个线程中会出现死锁。<code>synchronized</code>是对<code>pthread_metux_t</code>封装的递归锁。使用方便。</li>
<li>在使用锁的时候要万分小心。因为使用不当容易造成死锁或者增加运算量。</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-触摸事件总结" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/">iOS 触摸事件总结</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2020/05/04/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-05-03T16:00:00.000Z" itemprop="datePublished">2020-05-04</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS-触摸事件总结"><a href="#iOS-触摸事件总结" class="headerlink" title="iOS 触摸事件总结"></a>iOS 触摸事件总结</h1><h2 id="系统触摸事件生成传递"><a href="#系统触摸事件生成传递" class="headerlink" title="系统触摸事件生成传递"></a>系统触摸事件生成传递</h2><ol>
<li>当手指触摸屏幕的时候,产生中断.IOKit.framework接受中断，并且封装成IOHIDEvent对象。</li>
<li>系统利用进程间通信将对象传递给SpringBoard.app,SpringBoard是iOS的系统app，主要就是iOS的桌面系统。它负责管理触摸事件的分发。</li>
<li>SpringBoard根据这个事件进行分发，当主页面是我们开发的app的时候，即分发给我们的app。IOKit -&gt; SpringBoard -&gt; OurApp 这里面的数据传递都是进程间通信IPC</li>
<li>app主线程的Runloop在不断循环中或者在睡眠中被唤醒处理系统的Source1事件，即开始响应这个事件。</li>
<li>Source1是系统消息，传递过来的IOHIDEvent将交由Source0处理。</li>
<li>source0中将IOHIDEvent转化成UIEvent，并且调用UIApplication中的sendEvent方法，确定谁是最佳响应者。<br>以上步骤就是一个手势生给我们app处理的具体步骤</li>
</ol>
<h2 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a>UITouch</h2><ol>
<li>一次触摸生成一个UITouch对象。多点触控生成多个UITouch对象</li>
<li>多个手指先后触摸，根据算法判断是一个手势的多次点击，还是不同的两个手势</li>
<li>每个Touch对象会存放一些信息，比如时间，位置，阶段等信息</li>
<li>当手指离开屏幕一定时间，touch结束，对象释放</li>
</ol>
<h2 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h2><p>在触摸时间生成的阶段我们可以看到，最终我们的app是要接受并且处理UIEvent对象的。一个触摸便是一个UIEvent，因为一个触摸事件可能是多点触摸，会包含若干个UITouch对象。</p>
<h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p>每个能响应事件的都是一个<code>UIResponder</code>对象，如<code>UIView</code>，<code>UIApplication</code>，<code>AppDelegate</code>，<code>UIViewController</code>。他们都可以处理事件<br><code>touchesBegin</code>,<code>touchMoved</code>,<code>touchCancelled</code>,<code>touchEnded</code></p>
<h2 id="寻找事件最佳响应者"><a href="#寻找事件最佳响应者" class="headerlink" title="寻找事件最佳响应者"></a>寻找事件最佳响应者</h2><p>当我们的app主线程Runloop调用Application的sendEvent的方法，已经走过了第一步事件的发送，第二部寻找最佳的事件响应者。<br>我们把app中的View想象成一个桌子上放着大大小小的千层饼。UIApplication就是桌面。Application想知道应该把事件交给哪个Responder对象处理，就要从千层饼的底层往上试。直到获得最终要去响应事件的对象。这个过程被称为hit test命中测试。</p>
<h4 id="hit-test"><a href="#hit-test" class="headerlink" title="hit test"></a>hit test</h4><p>hit test 既是响应的传递者，也是应答者。沿以下路径进行事件传递:Application -&gt; UIWindow -&gt; view -&gt; childView。主要做两件事</p>
<ol>
<li>本身是否可以响应事件？ userInterfaceEnabled = false不行，隐藏不行，alpha 小于0.01也不行。当然也需要在触控范围内</li>
<li>如果不能响应返回nil</li>
<li>如果能响应，没有子View传给自己，如果有则递归给子View进行hit test。</li>
</ol>
<h2 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h2><p>根据寻找最高优先级的响应者的逻辑，我们能得到从UIWindow 到 hit tested-view的过程获得整个链路的路径。如 UIWindow -&gt; UIViewController -&gt; UIView -&gt; UIView。这个最高优先级的响应者对这个事件有着绝对的控制权，可以决定是否独吞这个事件，也可以将这个事件往下传递。这个过程就是响应链。与寻找响应者是逆向的。我们这里要记住一点，最高优先级的响应者不一定会响应事件。</p>
<h4 id="响应者"><a href="#响应者" class="headerlink" title="响应者"></a>响应者</h4><p>响应者根据响应链的顺序来处理事件。而处理事件就是是否重写UIResponder中的方法。</p>
<ol>
<li>不重写。不响应事件，将事件传递给nextResponder</li>
<li>重写。不调用<code>super.touchBegin</code>。完全自己响应事件</li>
<li>重写。调用<code>super.touchBegin</code>，自己响应，也让nextResponder响应</li>
</ol>
<h2 id="复杂事件处理-UIResponder-UIControl-UIGesture-Recognizer"><a href="#复杂事件处理-UIResponder-UIControl-UIGesture-Recognizer" class="headerlink" title="复杂事件处理 UIResponder UIControl UIGesture Recognizer"></a>复杂事件处理 UIResponder UIControl UIGesture Recognizer</h2><ol>
<li>更高优先级的手势识别器。Window在将事件传递给hit tested-view之前会优先给手势识别器识别。如果能识别，就取消hit-tested view的事件响应。反之hit-tested view响应。</li>
<li>UIControl比父视图上的手势识别器有更高的优先级，同层级还是UIGesture Recognizer更高。原因是因为UIControl本质上还是UIResponder，只不过UIControl会阻止父视图上的手势识别器识别。当然这仅限于系统UIControl，自定义UIControl并无此作用。</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Code Review流程梳理" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/Code%20Review%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">Code Review流程梳理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2020/02/21/Code%20Review%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/" class="article-date">
  <time datetime="2020-02-20T16:00:00.000Z" itemprop="datePublished">2020-02-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Code-Review-流程梳理"><a href="#Code-Review-流程梳理" class="headerlink" title="Code Review 流程梳理"></a>Code Review 流程梳理</h1><h3 id="Code-Review-当前问题反馈"><a href="#Code-Review-当前问题反馈" class="headerlink" title="Code Review 当前问题反馈"></a>Code Review 当前问题反馈</h3><h4 id="时间的问题"><a href="#时间的问题" class="headerlink" title="时间的问题"></a>时间的问题</h4><p>小伙伴反馈时间是一个大问题。<br>我拿我个人举例子做romwe直播13天总共4000行代码，做outfit列表页重构6天总共2000行代码。一天平均产出300多行。而由报告指出最佳的code reivew是一小时500行。也就是如果一个组4个人，一天就需要2-3个小时去review代码，这样的现实条件肯定是不允许的。</p>
<h4 id="review的时候没有目标"><a href="#review的时候没有目标" class="headerlink" title="review的时候没有目标"></a>review的时候没有目标</h4><p>小组开始review却没有任何目标，review到底要review哪些点。在时间紧张的情况下，有没有目标，review也就像无头苍蝇能找到几个可以修改的点就完事了。</p>
<h4 id="review之后没有改进"><a href="#review之后没有改进" class="headerlink" title="review之后没有改进"></a>review之后没有改进</h4><p>辛辛苦苦做了review也发现了一些问题，但是没有修改，又或者说到了测试阶段，已经不太方便做大的调整。review之后的东西并没有去修改review的意义也就不复存在了。</p>
<h2 id="问题对策"><a href="#问题对策" class="headerlink" title="问题对策"></a>问题对策</h2><h4 id="定制Code-Review的目标"><a href="#定制Code-Review的目标" class="headerlink" title="定制Code Review的目标"></a>定制Code Review的目标</h4><p>检查点表明了我们对代码有着怎样的要求。一般有以下方向可以作为Code Review的检查点。</p>
<table>
<thead>
<tr>
<th align="center">检查点</th>
<th align="center">检查点说明</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">代码风格</td>
<td align="center">每个公司都有每个公司的代码风格，可以采用成熟的方案，可严可松。</td>
<td align="center">目前在研究机器来审阅这一块</td>
</tr>
<tr>
<td align="center">可读性</td>
<td align="center">包括注释，文档，方法名等。易于理解即可</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">错误检查</td>
<td align="center">检查业务逻辑等有无漏洞</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">单元测试覆盖度</td>
<td align="center">单元测试跑得通，基本上错误检查就少了。</td>
<td align="center">目前这块是空白</td>
</tr>
<tr>
<td align="center">小框架</td>
<td align="center">检查小的业务逻辑中是否存在与当前不符合的。比如应该用快速加车但是没用。应该符合某个业务规范没有符合。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">大框架</td>
<td align="center">检查大的方向是否符合规范。比如规定用MVC，却因为自己喜好用了MVVM等。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h4><p>目前发现几款工具可以用来Code Review。</p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>工具用途</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Upsource</td>
<td>Jetbrain用来Code Review的工具</td>
<td>需要购买，还在研究中</td>
</tr>
<tr>
<td>SonarQube</td>
<td>专门的Code Review工具</td>
<td>安卓不需要购买，Swift OC代码需要购买，正在研究中</td>
</tr>
<tr>
<td>安卓代码检查插件</td>
<td>Android 自带的代码检查工具</td>
<td>-</td>
</tr>
<tr>
<td>App code</td>
<td>Code Inject</td>
<td>检查代码中的错误，代码风格，拼写等。</td>
</tr>
<tr>
<td>目前已经测试过App Code可用，但是需要付费，效果可以。安卓代码检查插件很多，李敏在研究。目前在部署SonarQube看看整体的Code Review效果</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="流程闭环"><a href="#流程闭环" class="headerlink" title="流程闭环"></a>流程闭环</h4><p>针对review过后代码没有及时修改的问题。我们将收集每个版本过后的报告，作出公示，方便大家查看。<br>可以督促修改互相帮助。<br>报告的样式</p>
<h4 id="定期的全员交流代码"><a href="#定期的全员交流代码" class="headerlink" title="定期的全员交流代码"></a>定期的全员交流代码</h4><p>Code Review是大家相互学习，相互进步的过程。一个人写代码是闭门造车。<br>每两周组织一次安卓/iOS的内部Code Review分享。拿一块业务让作者来描述编写思路，大家一起交流。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/">https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/</a></p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-MVC架构演进" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/04/MVC%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/">MVC MVP MVVM模式演进</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/12/04/MVC%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" class="article-date">
  <time datetime="2019-12-03T16:00:00.000Z" itemprop="datePublished">2019-12-04</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于MVC-MVP-MVVM模式演进"><a href="#关于MVC-MVP-MVVM模式演进" class="headerlink" title="关于MVC MVP MVVM模式演进"></a>关于MVC MVP MVVM模式演进</h1><h2 id="最原始的MVC"><a href="#最原始的MVC" class="headerlink" title="最原始的MVC"></a>最原始的MVC</h2><p>最原始的MVC是model负责数据 View负责视图 Controller负责接收View的改变<br><img src="https://i.imgur.com/xcuJKgC.jpg"><br>原始的MVC，Model，View，Controller3者之间相互配合。但是由于3个实体联系紧密，没办法分离。</p>
<h2 id="iOS的MVC"><a href="#iOS的MVC" class="headerlink" title="iOS的MVC"></a>iOS的MVC</h2><p><img src="https://i.imgur.com/Gsabxb4.jpg"><br>很长时间看白胡子老头的MVC我都诧异了，这跟原始的MVC不是一个东西。<br>如图所示iOS的MVC框架将Model，Controller，View分离。Controller可以更新模型，更新View。Model可以发出通知，View可以通过target-action代理等等返回。与原始MVC不同的是，Model和View是相互不交流的，一定程度上降低了耦合。<br><img src="https://i.imgur.com/mErjGPA.jpg"></p>
<p>这样的MVC看似没啥问题。我们思索几个问题</p>
<ol>
<li>UIViewController我们充当的是View还是Controller</li>
<li>业务逻辑在哪里做</li>
<li>视图在哪里做，在哪里控制</li>
<li>网络请求呢？<br>以上的答案可能都在UIViewController,其实iOS的MVC，Model是很简单的抽离了。但是View和Controller并没有分离，UIViewController是又当View又当Controller，既要管理Model，又要处理网络请求，更新视图，处理视图回调等等。</li>
</ol>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>既然UIViewController又当View又当Controller，我们试着将这个模块拆分。而ViewController是继承在UIView之下的，我们把视图模块保留给UIViewController，命名一个新的东西叫Presenter。<br><img src="https://i.imgur.com/fHm3pzB.jpg"><br>Presenter更新模型和视图。也接受模型和视图的事件。<br>这其实与苹果的MVC非常相似，但是我们不要忘记那个庞大的UIViewController可是要处理视图布局的。它没有办法与视图分离，而MVP将Presenter不会有任何对视图的布局。Presneter持有视图，更新视图而已。<br>用代码展示了一段MVP的架构。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HelloView</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HelloViewPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> view:<span class="type">HelloView</span>, <span class="number">_</span> person:<span class="type">Person</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showHello</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPresenter</span>:<span class="title">HelloViewPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> view:<span class="type">HelloView</span></span><br><span class="line">    <span class="keyword">let</span> model:<span class="type">Person</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> view: <span class="type">HelloView</span>, <span class="number">_</span> person: <span class="type">Person</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">        <span class="keyword">self</span>.model = person</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view.sayHello()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHelloView</span>:<span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> label:<span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> button:<span class="type">UIButton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> button = <span class="type">UIButton</span>.<span class="keyword">init</span>(type: .system)</span><br><span class="line">        button.addTarget(<span class="keyword">self</span>, action: #selector(didClick(<span class="number">_</span>:)), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">        <span class="keyword">return</span> button</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter:<span class="type">HelloViewPresenter?</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">didClick</span><span class="params">(<span class="number">_</span> sender:<span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">        presenter?.showHello()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(label)</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(button)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyHelloView</span>:<span class="title">HelloView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.label.text = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MVP在苹果的MVC上进一步的区分了三个模块之间的关系，而且明确了UIViewController的职责所在。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://i.imgur.com/ZZDJcOy.jpg"><br>MVVM与MVP十分相似，UIViewController承担View的角色。View和Model之间不存在紧耦合。<br>不一样的是MVP中Presenter处理view的更新方法。而MVVM通过数据绑定，让视图处理视图的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name:String</span><br><span class="line">    var age:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol HelloViewModelProtocol: class &#123;</span><br><span class="line">    var hello:String? &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    var helloStrDidChange:((HelloViewModelProtocol) -&gt; ())? &#123;get set&#125;</span><br><span class="line">    init(_ person:Person)</span><br><span class="line">    func sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloViewModel:HelloViewModelProtocol &#123;</span><br><span class="line">    var helloStrDidChange: ((HelloViewModelProtocol) -&gt; ())?</span><br><span class="line">    let person:Person</span><br><span class="line">    required init(_ person: Person) &#123;</span><br><span class="line">        self.person &#x3D; person</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @objc func sayHello() &#123;</span><br><span class="line">        self.hello &#x3D; &quot;hello \(Date.init().description)&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var hello:String? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            self.helloStrDidChange?(self)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHelloView:UIViewController &#123;</span><br><span class="line">    var label:UILabel &#x3D; &#123;</span><br><span class="line">        let label &#x3D; UILabel.init()</span><br><span class="line">        return label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lazy var button:UIButton &#x3D; &#123;</span><br><span class="line">        let button &#x3D; UIButton.init(type: .system)</span><br><span class="line">        button.addTarget(self.viewModel, action: #selector(HelloViewModel.sayHello), for: .touchUpInside)</span><br><span class="line">        return button</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    var viewModel:HelloViewModel? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            self.viewModel?.helloStrDidChange &#x3D; &#123; [weak self] vm in</span><br><span class="line">                self?.label.text &#x3D; vm.hello</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        self.view.addSubview(label)</span><br><span class="line">        self.view.addSubview(button)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let model &#x3D; Person.init(name: &quot;foo&quot;, age: &quot;12&quot;)</span><br><span class="line">let vm &#x3D; HelloViewModel.init(model)</span><br><span class="line">let vc &#x3D; MyHelloView.init()</span><br><span class="line">vc.viewModel &#x3D; vm</span><br></pre></td></tr></table></figure>
<p>同样的一个例子，与MVP中不同的是，ViewModel中并不添加额外的代码对View进行操作。<br>MVVM将MVP中对View的操作放回了视图。通过数据绑定可以更加方便的将view和controller进行分离。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里讨论的MVC是苹果的MVC，即苹果改进的MVC</p>
<ol>
<li>MVC MVP MVVM只是不断的职责分离不断地解耦地过程。</li>
<li>本质上MVC MVP MVVM只是叫法上的不同。Model一直代表的是数据层。V一直代表的是视图层。而C P VM是不同的职责划分对于控制逻辑这块不同的叫法。</li>
<li>MVC中，V和C相互有紧密的耦合，UIViewController职责不明。</li>
<li>MVP中，在MVC的基础上，把UIViewController的职责明确成View视图层。将其中Controller的部分用Presenter来承担，Presenter作为View和Model的媒介，即更新Model也更新View。</li>
<li>MVVM中 在MVP的基础上觉得Presenter中对视图的更新，应该让视图去做。加上响应式的编程方式，使得MVVM看起来特别优美。</li>
<li>MVC是经典的UI组织框架，用起来简单方便。</li>
<li>MVP，MVVM在MVC的基础上进行了改进。改进的优点是解耦，易测试。改进之后会让代码变得更多，有很多代码花费在数据绑定等操作上。而MVVM配合响应式的编程方式写得好会很优美，写不好会加大测试难度。</li>
<li>MVVM的创造者也说过MVVM在小型的UI场景中不适合，在大型的UI场景下，数据绑定又会很花时间，所以如何选择适合的框架还是看团队。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52</a><a target="_blank" rel="noopener" href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52</a>)</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Instrument 使用技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/30/Instrument%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Instrument 使用技巧</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/11/30/Instrument%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="article-date">
  <time datetime="2019-11-29T16:00:00.000Z" itemprop="datePublished">2019-11-30</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Instrument-使用技巧"><a href="#Instrument-使用技巧" class="headerlink" title="Instrument 使用技巧"></a>Instrument 使用技巧</h1><h2 id="对CPU性能进行追踪"><a href="#对CPU性能进行追踪" class="headerlink" title="对CPU性能进行追踪"></a>对CPU性能进行追踪</h2><p><img src="https://i.imgur.com/V55ZtzW.png" alt="WeChatWorkScreenshot_7cf7ac1c-55d4-47c7-bcc7-3299f7a8b332"></p>
<h2 id="Leaks"><a href="#Leaks" class="headerlink" title="Leaks"></a>Leaks</h2><p>对内存泄漏进行追踪。<br><img src="https://i.imgur.com/UtaAUjp.jpg" alt="-w299"><br>对于内存泄漏的追踪有3种维度。</p>
<ol>
<li><code>Leaks</code>具体泄漏的对象。</li>
<li><code>Cycles &amp; Roots</code>泄漏内存的对象关系</li>
<li><code>Call Tree</code>具体泄漏所在的方法<br>这三个我们能从不同维度对泄漏对象进行追踪。</li>
</ol>
<p>一般检查模式（debug模式需要DSYM文件，以便查看符号）</p>
<ol>
<li>查看<code>Call Tree</code> </li>
<li>在底部筛选<code>Call Tree</code>,去除系统方法。</li>
<li>底部<code>Call Tree Constraints</code>进行大小筛选。</li>
<li>底部<code>Data mining</code>可以对当前已经泄漏的对象进行数据分析。比如可以分析是哪个库产生的，去除一些杂数据，找到真正自己编码中国出问题的位置。</li>
<li>点击相应的内容，右侧可以查看具体的栈信息/或者记录信息<br><img src="https://i.imgur.com/Ekyttcn.png" alt="WeChatWorkScreenshot_e5d281ed-a221-4adc-a5a7-856f116ed422"></li>
</ol>
<h2 id="Timer-Profile"><a href="#Timer-Profile" class="headerlink" title="Timer Profile"></a>Timer Profile</h2><ol>
<li>查看每个方法的耗时.可以根据线程来看时常。可以看双核CPU中其中一个核心调用方法的耗时</li>
<li>可以查看App Life Cycle。<br><img src="https://i.imgur.com/qMLGlpD.jpg" alt="-w798"></li>
</ol>
<p><img src="https://i.imgur.com/GcdAGNz.jpg" alt="-w569"></p>
<h2 id="View-Debuging"><a href="#View-Debuging" class="headerlink" title="View Debuging"></a>View Debuging</h2><p>在真机调试图层的时候，我们选中Xcode任务栏中的<code>Debug</code>-&gt;<code>View Debugging</code>-&gt;<code>Rendering</code><br><img src="https://i.imgur.com/3sfoVwb.jpg" alt="-w240"></p>
<ol>
<li>Color Blended Layers.图层混合，红色为混合图层，绿色为没有使用混合图层。这个跟业务设计相关，能不混合就不混合。实在要混合，问题也不大。</li>
<li>Color Hits Green and Missed Red。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</li>
<li>Color Copied Images.如果GPU不支持这种图片格式，会交给CPU进行格式转化，标记为蓝色。</li>
<li>Color layer Formats. 区分不同的图片格式</li>
<li>Color Misaligned Images. 与布局不符合的展示相关颜色。</li>
<li>Color Offscreen-Rendered Yellow。离屏渲染展示黄色</li>
<li>Color Compositing Fast-Path Blue.有使用色彩合成快速通道的展示为蓝色。</li>
<li>Flash Updated Regions.展示刷新UI的区域</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Cocoapod私有库搭建" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/20/Cocoapod%E7%A7%81%E6%9C%89%E5%BA%93%E6%90%AD%E5%BB%BA/">Cocoapods私有库</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/04/20/Cocoapod%E7%A7%81%E6%9C%89%E5%BA%93%E6%90%AD%E5%BB%BA/" class="article-date">
  <time datetime="2019-04-19T16:00:00.000Z" itemprop="datePublished">2019-04-20</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS-CococaPod私有库开发环境搭建"><a href="#iOS-CococaPod私有库开发环境搭建" class="headerlink" title="iOS CococaPod私有库开发环境搭建"></a>iOS CococaPod私有库开发环境搭建</h1><p>我们搭建私有库的目的是共享一个team的组件化代码。<br>环境变量：cocoapods -v=1.8.4</p>
<h2 id="私有库组成"><a href="#私有库组成" class="headerlink" title="私有库组成"></a>私有库组成</h2><p>搭建整套私有库，我们有两种</p>
<ol>
<li>源代码仓库: 比如我们有组件为MyUIKit,MyTimeKit等。</li>
<li>spec仓库 : 存储了源代码仓库的podSpec文件的仓库。</li>
</ol>
<h2 id="私有库原理"><a href="#私有库原理" class="headerlink" title="私有库原理"></a>私有库原理</h2><p>源文件仓库很容易理解，就是源代码仓库，当一个team体量大了之后会有很多源代码仓库。</p>
<p>spec仓库相当于是一个版本管理仓库，我们使用CocoaPod源码仓库中会有spec文件，当我们修改spec文件，然后push到spec仓库中的时候，仓库就记录下了源码仓库的spec文件.长时间下来会有不同的源码仓库文件夹，文件夹中包含这个源码仓库的历史版本。</p>
<p>如果我们的目标工程或者说主工程，直接用branch，或者commit作为依赖，那么是不需要第二种仓库的。</p>
<p>使用CocoaPod管理，Spec是个非常重要的文件,这个文件管理着源代码库的基本信息和依赖关系。不同的历史版本依赖着不同的第三方库。</p>
<h2 id="简单搭建私有库步骤"><a href="#简单搭建私有库步骤" class="headerlink" title="简单搭建私有库步骤"></a>简单搭建私有库步骤</h2><blockquote>
<p>mac中已经安装cocoapod和git.并且有远程仓库的服务.</p>
</blockquote>
<ol>
<li>创建源代码仓库</li>
<li>设置remote地址</li>
<li>设置源代码仓库的Spec文件,并且验证可用性</li>
<li>创建spec仓库,并且拉代码到本地</li>
<li>将源码仓库添加到spec仓库中</li>
<li>更新源码仓库，将更新的内容同步到spec仓库中</li>
</ol>
<h3 id="创建源代码仓库"><a href="#创建源代码仓库" class="headerlink" title="创建源代码仓库"></a>创建源代码仓库</h3><p>在你需要的位置创建源代码仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> cd ~&#x2F;Desktop  &#x2F;&#x2F;指向桌面文件夹</span><br><span class="line"></span><br><span class="line">pod lib create YourLib    &#x2F;&#x2F;pod快捷创建lib,你需要做一些选项，然后</span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS &#x2F; macOS ]</span><br><span class="line"> &gt; iOS</span><br><span class="line"></span><br><span class="line">What language do you want to use?? [ Swift &#x2F; ObjC ]</span><br><span class="line"> &gt; Swift</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes &#x2F; No ]</span><br><span class="line"> &gt; Yes</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Quick &#x2F; None ]</span><br><span class="line"> &gt; None</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes &#x2F; No ]</span><br><span class="line"> &gt; No</span><br></pre></td></tr></table></figure>
<p>这样已经在Desktop中生成好了我们的工程。</p>
<p>###添加远端设置remote地址<br>创建远程的仓库 记下repo的地址，下一步要更新到podspec文件的source中。<br><strong>创建git远端仓库有许多种，这边就不赘述了。总之达到目的即可</strong></p>
<h3 id="配置源码仓库Spec文件"><a href="#配置源码仓库Spec文件" class="headerlink" title="配置源码仓库Spec文件"></a>配置源码仓库Spec文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">YourSDK</span><br><span class="line">├── Example</span><br><span class="line">│   ├── Podfile</span><br><span class="line">│   ├── Podfile.lock</span><br><span class="line">│   ├── Pods</span><br><span class="line">│   ├── Tests</span><br><span class="line">│   ├── YourSDK</span><br><span class="line">│   ├── YourSDK.xcodeproj</span><br><span class="line">│   └── YourSDK.xcworkspace</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── YourSDK</span><br><span class="line">│   ├── Assets</span><br><span class="line">│   └── Classes</span><br><span class="line">├── YourSDK.podspec</span><br><span class="line">└── _Pods.xcodeproj -&gt; Example&#x2F;Pods&#x2F;Pods.xcodeproj</span><br></pre></td></tr></table></figure>
<p>这是这个库的大体结构。我们在Classes中添加代码文件在Assets中添加资源。<br>现在Classes中有一个类ReplaceMe.swift,删除并且新增一个类</p>
<p>写下你要的代码。因为是库，所以基本上类，属性都要加<code>public</code>关键字，否则无法识别。<br>接下来修改  YourSDK.podspec  文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name             &#x3D; &#39;YourSDK&#39;</span><br><span class="line">  s.version          &#x3D; &#39;0.1.0&#39;</span><br><span class="line">  s.summary          &#x3D; &#39;A short description of YourSDK.&#39;</span><br><span class="line"></span><br><span class="line">  s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">TODO: Add long description of the pod here.</span><br><span class="line">                       DESC</span><br><span class="line"></span><br><span class="line">  s.homepage         &#x3D; &#39;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;YourSDK&#39;</span><br><span class="line">  s.license          &#x3D; &#123; :type &#x3D;&gt; &#39;MIT&#39;, :file &#x3D;&gt; &#39;LICENSE&#39; &#125;</span><br><span class="line">  s.author           &#x3D; &#123; &#39;xxx&#39; &#x3D;&gt; &#39;xxx@xxx.com&#39; &#125;</span><br><span class="line">  s.source           &#x3D; &#123; :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;YourSDK.git&#39;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line">  s.swift_versions &#x3D; &#39;4.2&#39;</span><br><span class="line">  s.ios.deployment_target &#x3D; &#39;8.0&#39;</span><br><span class="line">  s.source_files &#x3D; &#39;YourSDK&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>将<code>xxx</code>更新为你的信息。homepage和source更新成远端仓库。并且检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用 pod lib lint</span><br><span class="line">cd YourSDK</span><br><span class="line">pod lib lint</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果有问题，按照提示去解决Error，WARN。此处因为我的classes中没有文件为空pod，所以报错。</span><br><span class="line">-&gt; YourSDK (0.1.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line">    - WARN  | url: The URL (https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;YourSDK) is not reachable.</span><br><span class="line">    - ERROR | [iOS] file patterns: The &#96;source_files&#96; pattern did not match any file.</span><br><span class="line">    - NOTE  | xcodebuild:  note: Using new build system</span><br><span class="line">    - NOTE  | [iOS] xcodebuild:  note: Planning build</span><br><span class="line">    - NOTE  | [iOS] xcodebuild:  note: Constructing build description</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>解决完Error，下面关联远端仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitlab.xxxxx.com:xxx&#x2F;yoursdk.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="创建Spec仓库"><a href="#创建Spec仓库" class="headerlink" title="创建Spec仓库"></a>创建Spec仓库</h3><p>在我们的远端创建一个仓库，按照cocoaPod的习惯，基本上是<code>http://gitlab.xxx.com:xxx/YourSpec.git </code> 样式.<br><strong>创建git远端仓库有许多种，这边就不赘述了。总之达到目的即可</strong></p>
<h3 id="本地pod设置"><a href="#本地pod设置" class="headerlink" title="本地pod设置"></a>本地pod设置</h3><p>现在远端spec仓库已经存在，我们把仓库拉到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;pod repo add [specName] [remoteSpec.git]</span><br><span class="line">&#x2F;&#x2F;例如</span><br><span class="line">pod repo add mysdk http:&#x2F;&#x2F;gitlab.xxx.com:xxx&#x2F;Spec.git</span><br><span class="line">pod repo  &#x2F;&#x2F;查看一下是不是添加成功了</span><br><span class="line"></span><br><span class="line">hzSpec</span><br><span class="line">- Type: git (master)</span><br><span class="line">- URL:  http:&#x2F;&#x2F;gitlab.xxxx.com:8088&#x2F;xxx&#x2F;Spec.git</span><br><span class="line">- Path: &#x2F;Users&#x2F;xxx&#x2F;.cocoapods&#x2F;repos&#x2F;hzSpec</span><br><span class="line"></span><br><span class="line">master</span><br><span class="line">- Type: git (master)</span><br><span class="line">- URL:  https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git</span><br><span class="line">- Path: &#x2F;Users&#x2F;xxx&#x2F;.cocoapods&#x2F;repos&#x2F;master</span><br></pre></td></tr></table></figure>

<h3 id="关联源代码仓库到Spec仓库"><a href="#关联源代码仓库到Spec仓库" class="headerlink" title="关联源代码仓库到Spec仓库"></a>关联源代码仓库到Spec仓库</h3><p>现在跳回到我们的源代码仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;Desktop&#x2F;YourSDK</span><br><span class="line">&#x2F;&#x2F;这一步是将YourSDK.podspec文件上传到spec上去</span><br><span class="line">pod repo push [specName] YourSDK.podspec</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面检测一下是否有配置问题，问题有几种Error必须解决，Warnings也最好解决，如果不想解决在命令后加入 --allow-warnings即可</span><br><span class="line">&#x2F;&#x2F;本地检测</span><br><span class="line">pod spec lint</span><br><span class="line">&#x2F;&#x2F;检测远程仓库问题</span><br><span class="line">pod search YourSDK</span><br></pre></td></tr></table></figure>
<p>上述无问题环境就搭建完成了</p>
<h3 id="更新源码仓库，并且更新到spec仓库"><a href="#更新源码仓库，并且更新到spec仓库" class="headerlink" title="更新源码仓库，并且更新到spec仓库"></a>更新源码仓库，并且更新到spec仓库</h3><p>如果我们对库进行了更新，要更新版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod repo push [specName] YourSDK.podspec </span><br><span class="line">pod repo update [specName] </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="一些tips"><a href="#一些tips" class="headerlink" title="一些tips"></a>一些tips</h3><ol>
<li>当我们自己的库依赖于自己的其他库时，需要–source=YOUR_OWN_SPEC_REPO</li>
<li>pod命令的提示非常友好，可以根据pod的提示来进行操作</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-GCD小记" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/14/GCD%E5%B0%8F%E8%AE%B0/">GCD 使用小记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/06/14/GCD%E5%B0%8F%E8%AE%B0/" class="article-date">
  <time datetime="2018-06-13T16:00:00.000Z" itemprop="datePublished">2018-06-14</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="GCD-使用小记"><a href="#GCD-使用小记" class="headerlink" title="GCD 使用小记"></a>GCD 使用小记</h1><h2 id="GCD（grand-center-dispatch）"><a href="#GCD（grand-center-dispatch）" class="headerlink" title="GCD（grand center dispatch）"></a>GCD（grand center dispatch）</h2><p>MacOS/iOS 中gcd对于线程的管理可谓是方便极了。gcd不是线程，也不是线程的封装。而是一个对线程管理的库。它让我们忘掉繁杂的线程管理而专注于业务。gcd的本质就是FIFO的将任务交给指定的队列。</p>
<ul>
<li>Dispatch Groups        // coordinate groups of queues</li>
<li>Semaphores             // traditional counting Semaphores</li>
<li>Barriers               // synchronize tasks in a given concurrent queue</li>
<li>Dispatch Sources       // event handling for low-level events</li>
<li>Dispatch I/O           // file descriptor–based operations</li>
<li>Dispatch Data Buffers  // memory-based data buffer</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>gcd给我们一个队列的认识。队列分为2种，一种是串行，一种是并行。<br>串行队列:给串行队列按照FIFO顺序提交任务，任务会一个一个的执行，会按照FIFO的顺序输出。<br>并行队列也会按照FIFO的顺序去提交任务，但是跟串行队列不一样，并行队列可以创建新的线程去执行任务。无法保证任务输出的顺序<br>主队列是特殊的串行队列。UI任务必须要在主线程上执行。主线程与Runloop配合。主线程上要避免复杂的执行，保证UI任务的执行。</p>
<h4 id="同步方法与异步方法"><a href="#同步方法与异步方法" class="headerlink" title="同步方法与异步方法"></a>同步方法与异步方法</h4><p>给队列添加任务的方式有2种。<br><code>async</code>:异步提交一个任务然后迅速返回不等任务结束。<br><code>sync</code> :同步提交一个任务等待任务完成才返回。<br>如果我们在主队列中调用主队列的同步方法会造成崩溃，原因就是串行队列无法完成队列末尾的任务。</p>
<p>异步方法:<code>async</code>,<code>after</code>,<code>apply</code><br>同步方法:<code>once</code>, <code>sync</code></p>
<h4 id="主线程异步修改UI"><a href="#主线程异步修改UI" class="headerlink" title="主线程异步修改UI"></a>主线程异步修改UI</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateUI &#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;update UI&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="延迟执行任务"><a href="#延迟执行任务" class="headerlink" title="延迟执行任务"></a>延迟执行任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)delayTask &#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;dispatch after 2 secs&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="once单例"><a href="#once单例" class="headerlink" title="once单例"></a>once单例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)once &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">       &#x2F;&#x2F;不管调用多少次，只会执行一次，单例模板</span><br><span class="line">        NSLog(@&quot;only once&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="apply-异步循环执行"><a href="#apply-异步循环执行" class="headerlink" title="apply 异步循环执行"></a>apply 异步循环执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)apply&#123;</span><br><span class="line">    dispatch_apply(3, dispatch_get_global_queue(0, 0), ^(size_t t) &#123;</span><br><span class="line">        if(t &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            for(int i &#x3D; 0;i&lt;5;i++) &#123;</span><br><span class="line">                NSLog(@&quot;%d&quot;,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            NSLog(@&quot;---&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建一个队列"><a href="#创建一个队列" class="headerlink" title="创建一个队列"></a>创建一个队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)createDispatchLabel &#123;</span><br><span class="line">    dispatch_queue_t someQueue &#x3D; dispatch_queue_create(&quot;huzhou&quot;, nil);</span><br><span class="line">    dispatch_async(someQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,dispatch_queue_get_label(someQueue));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="semaphore简介"><a href="#semaphore简介" class="headerlink" title="semaphore简介"></a>semaphore简介</h4><p>gcd的信号量是控制访问资源的方式。当多任务同时访问有限资源时，我们不能都满足，因为可能会造成获取数据不准确等情况。使用信号量主要有几个步骤</p>
<ol>
<li>创建信号量,dispatch_semaphore_create(2)比如创建一个资源数为2的信号量。也就是同时可以有2个任务可以访问资源。</li>
<li>一个任务在访问资源信号量资源之前需要调用<code>dispatch_semaphore_wait(mySemaphore, DISPATCH_TIME_FOREVER);</code>。这里的意思就是，任务在排队等待调用资源，如果有空余资源，会执行任务。如果没有空余资源，任务会处于等待状态。</li>
<li>执行完任务，需要释放信号量。<code>dispatch_semaphore_signal(mySemaphore);</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)useSemaphore &#123;</span><br><span class="line">    &#x2F;&#x2F;创建一个容量为3的信号量</span><br><span class="line">    mySemaphore &#x3D; dispatch_semaphore_create(2);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        [self semaphoreTaskOne];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        [self semaphoreTaskTwo];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        [self semaphoreTaskThree];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)semaphoreTaskOne &#123;</span><br><span class="line">    dispatch_semaphore_wait(mySemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    sleep(3);</span><br><span class="line">    NSLog(@&quot;do one&quot;);</span><br><span class="line">    dispatch_semaphore_signal(mySemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)semaphoreTaskTwo &#123;</span><br><span class="line">    dispatch_semaphore_wait(mySemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    sleep(3);</span><br><span class="line">    NSLog(@&quot;do two&quot;);</span><br><span class="line">    dispatch_semaphore_signal(mySemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)semaphoreTaskThree &#123;</span><br><span class="line">    dispatch_semaphore_wait(mySemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    sleep(3);</span><br><span class="line">    NSLog(@&quot;do three&quot;);</span><br><span class="line">    dispatch_semaphore_signal(mySemaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatch-Groups使用"><a href="#Dispatch-Groups使用" class="headerlink" title="Dispatch Groups使用"></a>Dispatch Groups使用</h4><p>我们把一些异步任务组成组合，当所有的任务完成了才触发下一步的任务。<br>举个例子，如果我一个页面需要异步调用a,b两个接口，结合ab两个接口的数据才能进行ui的更新。那么我们就可以使用group了。下面是主要步骤</p>
<ol>
<li>创建<code>dispatch_group_t</code></li>
<li>使用<code>dispatch_group_async</code>（下面例子中的1，3块）或者是<code>dispatch_group_enter</code>，<code>dispatch_group_leave(group);</code>组合（下面的例子中的第二块）。</li>
<li>收集group信息。当group任务都部署完成了，我们需要一个方法来明确group任务都做完了，可以进行下一步骤了。主要有两种方式<code>dispatch_group_notify</code>和<code>dispatch_group_wait</code>。<code>dispatch_group_notify</code>是不阻塞当前线程，用block来执行group都执行完后的动作。而<code>dispatch_group_wait</code>方法阻塞当前线程直到group任务都完成。下面的例子中可以看到如果使用<code>dispatch_group_notify</code>方法<code> NSLog(@&quot;notify 后&quot;);</code>指令会很快执行。而使用<code>dispatch_group_wait</code>方法，<code> NSLog(@&quot;notify 后&quot;);</code>会在所有任务之后执行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatchGroupWait &#123;</span><br><span class="line">    dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;do something 1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;do something 2&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;do something 3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;notify 前&quot;);</span><br><span class="line">    dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;任务1，2，3 finish&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;notify 后&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><p>barrier顾名思义栅栏，是给队列中的任务以一个阻碍的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)barrierTest &#123;</span><br><span class="line">    &#x2F;&#x2F;barrier只作用在自创建的队列里</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;huzhou 2&quot;, nil);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; 10;i ++) &#123;</span><br><span class="line">            NSLog(@&quot;barrier 之前 %d&quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;---- barrier --- &quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; 10;i ++) &#123;</span><br><span class="line">            NSLog(@&quot;barrier 之后 %d&quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h4><p>用来处理一些系统底层的事件。<br>Timer Dispatch Source：定时调度源。<br>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。<br>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。<br>Process Dispatch Source：监听进程相关状态的调度源。<br>Mach port Dispatch Source：监听Mach相关事件的调度源。<br>Custom Dispatch Source：监听自定义事件的调度源。<br>可以针对这些类型进行监听，比如监听Timer返回，然后响应事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)dispatchSourceTimer &#123;</span><br><span class="line">    dispatch_source_t sourceTime &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));</span><br><span class="line">    if(sourceTime) &#123;</span><br><span class="line">        dispatch_time_t startTime  &#x3D; dispatch_time(DISPATCH_TIME_NOW, 0 * NSEC_PER_SEC);</span><br><span class="line">        dispatch_source_set_timer(sourceTime, startTime, 1 * NSEC_PER_SEC, 0);</span><br><span class="line">        __block int count &#x3D; 0;</span><br><span class="line">        dispatch_source_set_event_handler(sourceTime, ^&#123;</span><br><span class="line">            NSLog(@&quot;source time &quot;);</span><br><span class="line">            count ++;</span><br><span class="line">            if (count &#x3D;&#x3D; 5) &#123;</span><br><span class="line">                dispatch_cancel(sourceTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_source_set_cancel_handler(sourceTime, ^&#123;</span><br><span class="line">            NSLog(@&quot;source time cancel&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_resume(sourceTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mySource &#x3D; sourceTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatch-I-O-amp-Dispatch-Data-Buffer"><a href="#Dispatch-I-O-amp-Dispatch-Data-Buffer" class="headerlink" title="Dispatch I/O &amp; Dispatch Data Buffer"></a>Dispatch I/O &amp; Dispatch Data Buffer</h4><p>读取大文件时，将文件分成合适的大小，然后用dispatch_io来进行读写。<br>目前未使用过，所以先放着。我们需要了解dispatch有这个功能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>gcd让我们在使用多线程的时候更加注重业务，而非线程切换等操作。</li>
<li>gcd给我们提供了2种队列。一种是串行队列，一种是并行队列，主队列是串行队列。串行队列会按照FIFO的顺序安排任务，然后按照FIFO输出。而并行队列按照FIFO顺序安排任务，不会确定执行完的顺序。</li>
<li>对于队列有两种安排任务的方法。同步与异步。同步方法需要等待任务完成再返回。而异步方法不需要等待任务执行完就返回。</li>
<li>以上3步已经确保了常规的任务调度流程。还要考虑一些特别的情况。</li>
<li>如果需要保证一个任务只会被调用一次。那么就要使用<code>once</code>方法。</li>
<li>如果要异步循环执行一些方法就可以使用<code>apply</code>方法。</li>
<li>如果几个任务同属一个组，那么我们可以使用<code>group</code>来管理这些组员。</li>
<li>当许多任务需要同时调用一个资源的时候，我们给资源一个信号量。当信号量大于0允许任务调用资源。否则任务等待信号量大于0才能调度资源。</li>
<li>之前说同一个组，可以使用group管理任务。如果任务不同组，需要等待它们完成才能进行一定的操作，我们可以使用<code>barrier</code>。</li>
<li>线程中，或者线程与线程之间会有一些消息的传递。gcd通过dispatch_source来监听消息，做一定的响应。</li>
<li>gcd中<code>dispatch_io</code>可以用来进行读写调度。使用<code>dispatch_io</code>来使用基于流或者随机访问的语义管理文件描述符。</li>
<li>gcd还通过 <code>dispatch data</code> 对象管理基于内存的数据缓冲区，并将其公开为连续的内存块。</li>
</ol>
<p><a href="media/15817769436621/GCDDemo.zip">GCDDemo</a></p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-iOS渲染小记" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/12/iOS%E6%B8%B2%E6%9F%93%E5%B0%8F%E8%AE%B0/">iOS 渲染小记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/12/12/iOS%E6%B8%B2%E6%9F%93%E5%B0%8F%E8%AE%B0/" class="article-date">
  <time datetime="2017-12-11T16:00:00.000Z" itemprop="datePublished">2017-12-12</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS渲染小记"><a href="#iOS渲染小记" class="headerlink" title="iOS渲染小记"></a>iOS渲染小记</h1><p>我们一谈到iOS的绘图，我们容易想到的词就是渲染，离屏渲染。</p>
<h2 id="什么是Render"><a href="#什么是Render" class="headerlink" title="什么是Render"></a>什么是Render</h2><p>Render这个词可以被翻译成渲染，也可以翻译成绘制。<br>在iOS中Render这个过程是将我们的UIView图形数据转化成屏幕上的各种矩形的过程。所以当我们谈到渲染也好，绘制也好对应的单词就是Render，代表的就是<strong>我们的数据变成可视图像的过程</strong>。</p>
<h2 id="iOS-Render的步骤"><a href="#iOS-Render的步骤" class="headerlink" title="iOS Render的步骤"></a>iOS Render的步骤</h2><ol>
<li>Commit Transaction 对我们业务中的UI数据进行提交</li>
<li>Decode 将提交的数据解析成一定的格式</li>
<li>Draw Calls 调用Metal/Open GL 等api，来操作GPU</li>
<li>GPU接收到了draw calls，进行Render，最后形成Frame Buffer提交给视频控制器</li>
<li>视频控制器接受到vsync信号，将Frame Buffer提交给显示器，进行展示。</li>
</ol>
<h4 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h4><p>GPU作为画家会将Render Server输入的数据，按照次序输出到frame buffer。比如一个带背景色的label，会先将背景色填入frame buffer中，然后再将text覆盖到frame buffer上，层层叠加，形成最终的状态。</p>
<h4 id="缓冲技术-与-垂直同步"><a href="#缓冲技术-与-垂直同步" class="headerlink" title="缓冲技术 与 垂直同步"></a>缓冲技术 与 垂直同步</h4><p>在常规的Render过程中无论是CPU还是GPU都会有缓冲区去存储已经处理好的数据以便给下一环节使用。CPU缓冲就是将计算好的draw calls存起来，等GPU拿这些数据。GPU缓冲就是将计算好的frame buffer，等待视频控制器来拿。这样的双缓冲机制可以很大程度上保持显示的流畅。</p>
<h4 id="卡顿的原因"><a href="#卡顿的原因" class="headerlink" title="卡顿的原因"></a>卡顿的原因</h4><p>即使我们已经有了双缓冲技术的加持,如果CPU/GPU任意一方负载过高无法在规定的时间内输出给下一步，那么我们产出的半成品将会被丢弃</p>
<h2 id="什么是Offscreen-Render"><a href="#什么是Offscreen-Render" class="headerlink" title="什么是Offscreen-Render"></a>什么是Offscreen-Render</h2><p>画家算法虽然可以按照layer向frame buffer输出，但是无法在渲染过程中回头改变某些部分，因为有些数据已经被永久的覆盖了。这个时候我们就需要借助Offscreen-buffer。比如当我们遇到了CornerRadius和MasktoBounds的时候。maskToBo</p>
<p>unds会应用到所有sublayer上。也就是sublayer也都要进行圆角和裁切，也就是sublayer在渲染完还不能丢弃，需要保存在offscreen中，然后再经过圆角裁切放入frame buffer中。</p>
<h2 id="哪些场景会出现Offscreen-Render"><a href="#哪些场景会出现Offscreen-Render" class="headerlink" title="哪些场景会出现Offscreen-Render"></a>哪些场景会出现Offscreen-Render</h2><ol>
<li>cornerRedius + maskToBounds </li>
<li>mask</li>
<li>shadow</li>
<li>shouldRasterize</li>
<li>GroupOpacity</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-iOS编译指令" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/04/iOS%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/">iOS 编译指令小记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/04/iOS%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/" class="article-date">
  <time datetime="2017-08-03T16:00:00.000Z" itemprop="datePublished">2017-08-04</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="attribute"><a href="#attribute" class="headerlink" title="_attribute_\"></a><em>_attribute_\</em></h1><p>iOS开发中__attribute__是一个编译指令，他可以对特定的属性，变量，类型进行设置。达到一定的效果。</p>
<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p><code>__attribute((format(printf,2,3)))</code>要求对printf函数符合格式。在OC中等同于<code>__NSString__</code>,<code>NS_FORMAT_FUNCTION(2,3)</code></p>
<h2 id="attribute-constructor"><a href="#attribute-constructor" class="headerlink" title="__attribute__((constructor))"></a><code>__attribute__((constructor))</code></h2><p>这样写在一个函数前面，确保函数在main方法前执行。跟<code>+ load()</code>方法相似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">static void beforMain() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="attribute-cleanup"><a href="#attribute-cleanup" class="headerlink" title="__attribute__((cleanup))"></a><code>__attribute__((cleanup))</code></h2><p>修饰的变量在作用于结束的时候调用cleanup方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void stringCleanUp(__strong NSString **string) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, *string);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 在某个方法中：</span><br><span class="line">&#123;</span><br><span class="line">    __strong NSString *string __attribute__((cleanup(stringCleanUp))) &#x3D; @&quot;sunnyxx&quot;;</span><br><span class="line">&#125; &#x2F;&#x2F; 当运行到这个作用域结束时，自动调用stringCleanUp</span><br></pre></td></tr></table></figure>
<p><a href="">http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/</a></p>
<p>参考：<a href="">https://www.jianshu.com/p/965f6f903114</a></p>

      

      
        
    </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/hejianxian" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2020 hulu 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a target="_blank" rel="noopener" href="https://github.com/hejianxian" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>