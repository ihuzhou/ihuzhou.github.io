<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hulu&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hulu&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hulu&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hulu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hulu&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.2.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main">
  
    <article id="post-交互基础" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/20/%E4%BA%A4%E4%BA%92%E5%9F%BA%E7%A1%80/">WKWebView js 交互基础</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2021/02/20/%E4%BA%A4%E4%BA%92%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-02-20T07:46:24.000Z" itemprop="datePublished">2021-02-20</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>WKWebView JS调用的基础.<br>WKUserContentController对象为JavaScript提供了一种发送消息的途径。它通过webViewConfiguration于一个webView建立联系，通俗的意思就是wkWebView.configuration.userContentController来进行消息配置</p>
<h4 id="web发送消息给原生"><a href="#web发送消息给原生" class="headerlink" title="web发送消息给原生"></a>web发送消息给原生</h4><p>web通过调用javascript代码 <code>window.webkit.messagehandlers.event.postMessage(message)</code>来进行消息的发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;web端js通过调用</span><br><span class="line">window.webkit.messageHandlers.sendString.</span><br><span class="line">            postMessage(&#39;hello&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="原生接受消息"><a href="#原生接受消息" class="headerlink" title="原生接受消息"></a>原生接受消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;给userContentController添加代理和event名称。与window.webkit.messageHandlers.sendString.</span><br><span class="line">            postMessage(&#39;hello&#39;);中的sendString对应</span><br><span class="line">webView.configuration.userContentController.add(self, name:&quot;sendString&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现代理func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span><br><span class="line">public func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) &#123;</span><br><span class="line">    &#x2F;&#x2F;解析message，name和body分别对应事件名和事件主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原生发送消息给web"><a href="#原生发送消息给web" class="headerlink" title="原生发送消息给web"></a>原生发送消息给web</h4><p>原生发消息给web是通过代码构建js语句，发送给web</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;编写js代码</span><br><span class="line">let jsStr &#x3D; &quot;document.body.style.backgroundColor &#x3D; red; &quot;</span><br><span class="line">&#x2F;&#x2F;调用webView的evaluateJavaScript方法调用web方法</span><br><span class="line">webView.evaluateJavaScript(jsStr) &#123; (result, error) in</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原生发送js，原生接收"><a href="#原生发送js，原生接收" class="headerlink" title="原生发送js，原生接收"></a>原生发送js，原生接收</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注册事件</span><br><span class="line">webView.configuration.userContentController.add(self, name: &quot;event&quot;)</span><br><span class="line">&#x2F;&#x2F;需要调用的js代码</span><br><span class="line">let jsStr &#x3D; &quot;window.webkit.messageHandlers.event.postMessage(hello);&quot;</span><br><span class="line">&#x2F;&#x2F;创建js对象</span><br><span class="line">let js &#x3D; WKUserScript.init(source: jsStr, injectionTime: .atDocumentEnd, forMainFrameOnly: true)</span><br><span class="line">&#x2F;&#x2F;调用userContent.Controller.addUserScript方法</span><br><span class="line">webView.configuration.userContentController.addUserScript(js)</span><br></pre></td></tr></table></figure>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-WKWebView预加载设计" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/20/WKWebView%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%AE%BE%E8%AE%A1/">WKWebView预加载设计</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2021/02/20/WKWebView%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2021-02-20T07:46:03.000Z" itemprop="datePublished">2021-02-20</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要预加载-WKWebView启动时间统计"><a href="#为什么要预加载-WKWebView启动时间统计" class="headerlink" title="为什么要预加载 - WKWebView启动时间统计"></a>为什么要预加载 - WKWebView启动时间统计</h2><p>WKWebView从开始到完成页面显示，要经历一连串的启动加载环节，这段时间都是白屏的。做启动优化需要知道白屏的阶段和如何降低每个阶段的等待时间。WKWebView启动到加载这段时间也是白屏，我们需要了解这段时间白屏的时间长度，这段时间的白屏是否需要优化。</p>
<p>将开始时间设置为WKWebView所在的ViewController的<code>viewDidLoad</code>方法，结束时间为<code>WKNavigationDelegate Start</code>的代理<code>didStartProvisionalNavigation</code>触发的时间。<br>测试机型为iPhone 11 pro max 13.6 simulator</p>
<table>
<thead>
<tr>
<th>VCStart(second)</th>
<th>RequestStart(second)</th>
<th>VCStart - RequestStart(ms)</th>
</tr>
</thead>
<tbody><tr>
<td>37.0606232</td>
<td>37.422271</td>
<td>360</td>
</tr>
<tr>
<td>72.887713</td>
<td>73.178119</td>
<td>290</td>
</tr>
<tr>
<td>81.504813</td>
<td>81.790588</td>
<td>290</td>
</tr>
<tr>
<td>86.703848</td>
<td>86.992729</td>
<td>290</td>
</tr>
<tr>
<td>93.193314</td>
<td>93.483578</td>
<td>290</td>
</tr>
<tr>
<td>97.89509</td>
<td>98.183564</td>
<td>290</td>
</tr>
<tr>
<td>05.3545132</td>
<td>05.6421251</td>
<td>290</td>
</tr>
<tr>
<td>75.025178</td>
<td>75.311763</td>
<td>290</td>
</tr>
<tr>
<td>79.290159</td>
<td>79.57753</td>
<td>280</td>
</tr>
<tr>
<td>82.056283</td>
<td>82.351499</td>
<td>300</td>
</tr>
</tbody></table>
<p>可以看出第一次启动时间为360ms，剩下都在290ms左右。也就是说白屏中有300ms左右的时间是WebView还未开始加载所消耗的时间。</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>探究WKWebView启动慢的原因，我们从网络上得出了一定的信息。大致意思是:当打开app的时候，是没有启动浏览器的内核的，app打开一个网页需要先启动浏览器内核，启动线程等行为消耗了很多时间。然而即使不是第一次打开webkit，也需要300ms，还是太长了。<br>Webkit到底干了啥？这个问题我们先放在后面的源码分析中。如果把启动时间作为一个既定事实，如何减少WKWebView的启动时间呢？</p>
<p>思路: 用单例保存一份预加载池。当需要对象的时候就从池中取。这样我们就节省了创建对象所花的时间。</p>
<p>同样的模拟器，用了预加载展示一下成果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ViewDidLoad time --- 1613723670.805345</span><br><span class="line">WKNavigationDelegate Start time --- 1613723670.850704</span><br><span class="line">ViewDidLoad time --- 1613723679.0514688</span><br><span class="line">WKNavigationDelegate Start time --- 1613723679.08476</span><br><span class="line">ViewDidLoad time --- 1613723681.143784</span><br><span class="line">WKNavigationDelegate Start time --- 1613723681.180709</span><br><span class="line">ViewDidLoad time --- 1613723683.224917</span><br><span class="line">WKNavigationDelegate Start time --- 1613723683.258789</span><br><span class="line">ViewDidLoad time --- 1613723685.407696</span><br><span class="line">WKNavigationDelegate Start time --- 1613723685.443756</span><br><span class="line">ViewDidLoad time --- 1613723687.196275</span><br><span class="line">WKNavigationDelegate Start time --- 1613723687.23295</span><br><span class="line">ViewDidLoad time --- 1613723689.6150699</span><br><span class="line">WKNavigationDelegate Start time --- 1613723689.651721</span><br><span class="line">ViewDidLoad time --- 1613723693.7213821</span><br><span class="line">WKNavigationDelegate Start time --- 1613723693.755662</span><br><span class="line">ViewDidLoad time --- 1613723696.286388</span><br><span class="line">WKNavigationDelegate Start time --- 1613723696.320518</span><br><span class="line">ViewDidLoad time --- 1613723698.907718</span><br><span class="line">WKNavigationDelegate Start time --- 1613723698.943841</span><br></pre></td></tr></table></figure>
<p>从页面打开到请求开始的时间间隔缩短到了50ms以内。方案可行</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>预加载池协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 预加载池</span><br><span class="line">protocol PreloadPool &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     池子中应该存放的对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 预加载队列</span><br><span class="line">    var queue : [Element] &#123;get set&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 池容量</span><br><span class="line">    var capacity : Int &#123;get&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 返回一个已经预加载完成的对象</span><br><span class="line">    func getItem() -&gt; Element?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现单例类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import WebKit</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 设置预加载池的数量</span><br><span class="line">let WKWebPoolCount: Int &#x3D; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;预加载池对象</span><br><span class="line">public class WKWebViewPool: PreloadPool &#123;</span><br><span class="line">    typealias Element &#x3D; WingWebView</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 预加载队列</span><br><span class="line">    var queue: [WingWebView] &#x3D; [] &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            &#x2F;&#x2F;池中对象不足，补充对象</span><br><span class="line">            if queue.count &lt; capacity &#123;</span><br><span class="line">                self.queue.append(WingWebView.init(UIScreen.main.bounds))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var capacity: Int &#x3D; WKWebPoolCount</span><br><span class="line">    &#x2F;&#x2F;队列锁</span><br><span class="line">    var lock &#x3D; NSLock.init()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 单例变量，全局控制</span><br><span class="line">    public static var shared : WKWebViewPool &#x3D; &#123;</span><br><span class="line">        let pool &#x3D; WKWebViewPool.init()</span><br><span class="line">        assert(WKWebPoolCount &gt; 0)</span><br><span class="line">        for _ in 0..&lt;WKWebPoolCount &#123;</span><br><span class="line">            pool.queue.append(WingWebView.init(UIScreen.main.bounds))</span><br><span class="line">        &#125;</span><br><span class="line">        return pool</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 全局的预加载方法</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter urlString: 接受一个url对象，用于先缓存css&#x2F;js静态资源</span><br><span class="line">    public func preload(_ urlString:String &#x3D; &quot;https:&#x2F;&#x2F;ihuzhou.github.io&quot;) &#123;</span><br><span class="line">        &#x2F;&#x2F;do some initial settings</span><br><span class="line">        let subview &#x3D; WingWebView.init(.zero)</span><br><span class="line">        subview.isHidden &#x3D; true</span><br><span class="line">        if let url &#x3D; URL.init(string: urlString) &#123;</span><br><span class="line">            subview.load(URLRequest.init(url: url))</span><br><span class="line">        &#125;</span><br><span class="line">        UIApplication.shared.windows.first?.addSubview(subview)</span><br><span class="line">        DispatchQueue.main.asyncAfter(deadline:.now() + 10 ) &#123;</span><br><span class="line">            subview.removeFromSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 获取一个预加载对象</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: 预加载WebView容器</span><br><span class="line">    public func getItem() -&gt; WingWebView? &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        defer &#123;</span><br><span class="line">            lock.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        return queue.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预加载池没有回收已经使用的WKWebView，而任由其释放，主要是考虑到WKWebView在使用的时候会设置代理，注册js event等，有一个清理的过程。清理不干净是很麻烦的，为了避免此类问题，就不重用了。</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-静态资源拦截设计" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/20/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%8B%A6%E6%88%AA%E8%AE%BE%E8%AE%A1/">WKWebView静态资源拦截</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2021/02/20/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%8B%A6%E6%88%AA%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2021-02-20T07:44:58.000Z" itemprop="datePublished">2021-02-20</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>如何拦截iOS中的WebView请求,目前发现的有两种方案。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>NSURLProtocol</td>
<td>1. 从UIWebView就存在的方案，可以快速移植到WK</td>
<td>1. 全局拦截  2. 需要调用私有方法，有被拒风险</td>
</tr>
<tr>
<td>WKURLSchemeHandler</td>
<td>1. 与WKWebView兼容良好 2. 可以针对单个WebView进行拦截</td>
<td>1. 需要屏蔽系统对http/https协议的缓存拦截 2. 只能适配iOS11及以上</td>
</tr>
</tbody></table>
<p>因为已经处于iOS14时代，且没有webview方案的约束，直接使用WKURLSchemeHandler是一个比较好的选择。</p>
<h2 id="1-需要关闭Webkit默认的对http-https的拦截"><a href="#1-需要关闭Webkit默认的对http-https的拦截" class="headerlink" title="1. 需要关闭Webkit默认的对http/https的拦截"></a>1. 需要关闭Webkit默认的对http/https的拦截</h2><p>WKURLSchemeHandler是无法直接处理http/https这样公认的Scheme的。根据源码推测，WebKit库对http/https进行了拦截缓存等处理，这样使得用户无法对http/https进行拦截。如果关闭WebKit对任何Scheme类型的拦截，那么就可以在代码中处理</p>
<p>为了验证推测，实现以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface WKWebView (CustomURLScheme)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation WKWebView (CustomURLScheme)</span><br><span class="line">+ (BOOL)handlesURLScheme:(NSString *)urlScheme &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>利用OC的Category特性，将原类的方法覆盖。现在发现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configuration.setURLSchemeHandler(handler, forURLScheme: <span class="string">&quot;http&quot;</span>)</span><br><span class="line">configuration.setURLSchemeHandler(handler, forURLScheme: <span class="string">&quot;https&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以正常拦截http/https了</p>
<h2 id="2-自定义URLSchemeHandler对象"><a href="#2-自定义URLSchemeHandler对象" class="headerlink" title="2. 自定义URLSchemeHandler对象"></a>2. 自定义URLSchemeHandler对象</h2><p>自定义的URLSchemeHandler对象需要实现<code>WKURLSchemeHandler</code>协议，实现其中最重要的两个方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HZWKURLHandler</span>: <span class="title">WKURLSchemeHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, start urlSchemeTask: WKURLSchemeTask)</span></span> &#123;</span><br><span class="line">        <span class="comment">//保存urlSchemeTask</span></span><br><span class="line">        urlSchemeInUse[urlSchemeTask.description] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">//请求准备</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask)</span></span> &#123;</span><br><span class="line">        urlSchemeInUse[urlSchemeTask.description] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者是拦截开始的方法，后者是拦截停止的方法.其中拦截最重要的参数<code>urlSchemeTask</code>对象，是实现以下协议的对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">WKURLSchemeTask</span> : <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request: <span class="type">URLRequest</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> response: URLResponse)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> data: Data)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didFinish</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didFailWithError</span><span class="params">(<span class="number">_</span> error: Error)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>梳理一下拦截的流程</p>
<ol>
<li>当我们拦截了一个链接 <code>urlSchemeTask</code>将request保存。</li>
<li>通过start 代理方法，让我们处理。处理完成调用<code>didReceive</code>，<code>didFinish</code>，<code>didFailWithError</code>等方法完成数据填充或请求失败。</li>
<li>在处理过程中可能会<code>stop urlSchemeTask</code>代理方法如果作用，表明urlSchemeTask已经释放，强行调用会野指针<strong>EXC_BAD_ACCESS</strong>，报错 <strong>This task has already been stopped</strong></li>
</ol>
<h2 id="3-实现网络加载-本地缓存"><a href="#3-实现网络加载-本地缓存" class="headerlink" title="3. 实现网络加载 + 本地缓存"></a>3. 实现网络加载 + 本地缓存</h2><p>拦截一个request，最主要的目的是自主决策如何应对这个request。一般处理有以下几种</p>
<ol>
<li>对js/css静态资源使用缓存技术</li>
<li>对于图片，可以与原生公用一套图片处理模块，减少图片在不同缓存体系下重复缓存</li>
<li>对动态数据使用原生请求，共用同一套请求模版，同一个请求头。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> headers = urlSchemeTask.request.allHTTPHeaderFields</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> requestUrlString = urlSchemeTask.request.url?.absoluteString <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对不同请求类型进行处理</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> accept = headers?[<span class="string">&quot;Accept&quot;</span>],</span><br><span class="line">         accept.<span class="built_in">contains</span>(<span class="string">&quot;image&quot;</span>)  &#123;</span><br><span class="line">         <span class="comment">//当接受到图片的时候，桥接本地SDWebImage处理，和原生共用一套缓存</span></span><br><span class="line">          photoRequest(urlSchemeTask)</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> requestUrlString.isJSOrCss() &#123;</span><br><span class="line">          <span class="comment">//当遇到js/css的时候先查一遍本地缓存</span></span><br><span class="line">          localRequest(urlSchemeTask)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//请求不处理，直接走网络</span></span><br><span class="line">          remoteRequest(urlSchemeTask)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-添加http-https拦截"><a href="#4-添加http-https拦截" class="headerlink" title="4. 添加http/https拦截"></a>4. 添加http/https拦截</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">WKWebViewConfiguration</span>.<span class="keyword">init</span>()</span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</span><br><span class="line">    <span class="keyword">let</span> handler = <span class="type">HZWKURLHandler</span>.shared</span><br><span class="line">    configuration.setURLSchemeHandler(handler, forURLScheme: <span class="string">&quot;http&quot;</span>)</span><br><span class="line">    configuration.setURLSchemeHandler(handler, forURLScheme: <span class="string">&quot;https&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> preferences =  <span class="type">WKPreferences</span>.<span class="keyword">init</span>()</span><br><span class="line">preferences.javaScriptCanOpenWindowsAutomatically = <span class="literal">true</span></span><br><span class="line">configuration.preferences = preferences</span><br><span class="line">configuration.userContentController = <span class="type">WKUserContentController</span>.<span class="keyword">init</span>()</span><br></pre></td></tr></table></figure>
<p>拦截方法主要是<code>configuration.setURLSchemeHandler(handler, forURLScheme: &quot;http&quot;)</code>在<code>WKWebViewConfiguration</code>对象中配置</p>
<h2 id="5-拦截过程中遇到的问题"><a href="#5-拦截过程中遇到的问题" class="headerlink" title="5. 拦截过程中遇到的问题"></a>5. 拦截过程中遇到的问题</h2><ol>
<li>在做图片拦截的时候我们需要将请求桥接到native的图片框架中，那么如何识别一个资源是图片资源就很重要。我们可以根据请求头中的Accept参数识别一个url是否是图片资源。打印一下请求图片的Accept参数 <code>image/png,image/svg+xml,image/*;q=0.8,video/*;q=0.8,*/*;q=0.5</code>，判断Accept中是否包含image即可判断请求内容是否为图片</li>
<li>urlSchemeTask释放问题，上面已经描述过了</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-iOS简单缓存设计" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/20/iOS%E7%AE%80%E5%8D%95%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/">iOS简单缓存设计</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2021/02/20/iOS%E7%AE%80%E5%8D%95%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2021-02-20T07:41:31.000Z" itemprop="datePublished">2021-02-20</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>缓存通过key,value之间的映射，当相同key出现时可以快速获得指定的value。作为加速资源文件读取的一种手段，广泛用于各种移动端场景中。在iOS中缓存可以分为两个层级，一个是内存层级，一个是磁盘层级。内存层级更加快速，但是占用不能过大，且保存时间跟随app的生命周期活动。磁盘缓存保存时间长，且磁盘资源相对于内存资源比较充足。</p>
<p>无论是内存缓存还是磁盘缓存。都要实现以下功能。</p>
<ol>
<li>判断是否包含某一个key</li>
<li>存一个key, value</li>
<li>取一个key, value</li>
<li>移除指定key的value</li>
<li>移除所有key, value</li>
<li>根据不同指标清除相应的key。比如存活时间，占用大小，存储数量。</li>
</ol>
<h2 id="缓存协议"><a href="#缓存协议" class="headerlink" title="缓存协议"></a>缓存协议</h2><p>Swift是面向协议编程的语言。开头先写协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">protocol HZCacheProtocol &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    &#x2F;&#x2F;缓存数量</span><br><span class="line">    var totalCount: UInt &#123; get &#125;</span><br><span class="line">    &#x2F;&#x2F;缓存占用空间</span><br><span class="line">    var totalCost: UInt &#123; get &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 返回是否包含某一个key</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter key:</span><br><span class="line">    func contains(_ key:AnyHashable) -&gt; Bool</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 返回key所对应的对象</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter key:</span><br><span class="line">    func getCache(for key:AnyHashable) -&gt; Element?</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 添加kv进入缓存对象中</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameters:</span><br><span class="line">    &#x2F;&#x2F;&#x2F;   - key:</span><br><span class="line">    &#x2F;&#x2F;&#x2F;   - value:</span><br><span class="line">    func setCache(_ key:AnyHashable, _ value:Element, _ cost: UInt)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 指定key移除缓存</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter key:</span><br><span class="line">    func remove(_ key:AnyHashable)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 移除所有缓存</span><br><span class="line">    func removeAll()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 根据缓存数量移除缓存</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter maxCount: 最大缓存数量</span><br><span class="line">    func clear(_ maxCount: UInt)</span><br><span class="line">    </span><br><span class="line">    func clearCost(_ maxCost: UInt)</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 根据缓存时间移除缓存</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter interval: 缓存生存时常</span><br><span class="line">    func clear(_ interval:TimeInterval)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LRU-数据结构"><a href="#LRU-数据结构" class="headerlink" title="LRU 数据结构"></a>LRU 数据结构</h2><p>通常在处理内存缓存的时候，我们需要一个数据结构来使得最近使用过, 修改过的缓存最后被清理，最早加入/未使用的缓存最先被清理。hashmap + 双向链表就成了最优的选择。hashmap可以实现O(1)的时间查找，双向链表可以保证缓存的使用/添加顺序。</p>
<p>列一下hashmap + 双向链表的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">class HZLinkedNode: NSObject &#123;</span><br><span class="line">    &#x2F;&#x2F;前结点</span><br><span class="line">    var prev: HZLinkedNode?</span><br><span class="line">    &#x2F;&#x2F;下一个结点</span><br><span class="line">    var next: HZLinkedNode?</span><br><span class="line">    </span><br><span class="line">    var key: AnyHashable</span><br><span class="line">    var value: Any</span><br><span class="line">    var cost: UInt</span><br><span class="line">    var time: TimeInterval</span><br><span class="line">    </span><br><span class="line">    init(_ key:AnyHashable, _ value:Any,_ cost:UInt &#x3D; 0,_ time:TimeInterval &#x3D; 0) &#123;</span><br><span class="line">        self.key &#x3D; key</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line">        self.cost &#x3D; cost</span><br><span class="line">        self.time &#x3D; time</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HZCacheMap: NSObject &#123;</span><br><span class="line">    var dict:[AnyHashable:HZLinkedNode] &#x3D; [:]</span><br><span class="line">    var totalCost: UInt &#x3D; 0</span><br><span class="line">    var totalCount: UInt &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    var head: HZLinkedNode?</span><br><span class="line">    var tail: HZLinkedNode?</span><br><span class="line">    </span><br><span class="line">    func insertHead(_ node:HZLinkedNode) &#123;</span><br><span class="line">        self.dict[node.key] &#x3D; node</span><br><span class="line">        totalCost +&#x3D; node.cost</span><br><span class="line">        totalCount +&#x3D; 1</span><br><span class="line">        if head !&#x3D; nil &#123;</span><br><span class="line">            node.next &#x3D; head</span><br><span class="line">            head?.prev &#x3D; node</span><br><span class="line">            head &#x3D; node</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head &#x3D; node</span><br><span class="line">            tail &#x3D; node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func bringNodeToHead(_ node:HZLinkedNode) &#123;</span><br><span class="line">        guard head !&#x3D; node else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if tail &#x3D;&#x3D; node &#123;</span><br><span class="line">            tail &#x3D; node.prev</span><br><span class="line">            tail?.next &#x3D; nil</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.next?.prev &#x3D; node.prev</span><br><span class="line">            node.prev?.next &#x3D; node.next</span><br><span class="line">        &#125;</span><br><span class="line">        node.next &#x3D; head</span><br><span class="line">        node.prev &#x3D; nil</span><br><span class="line">        head?.prev &#x3D; node</span><br><span class="line">        head &#x3D; node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func removeNode(_ node:HZLinkedNode) &#123;</span><br><span class="line">        dict.removeValue(forKey: node.key)</span><br><span class="line">        totalCount -&#x3D; 1</span><br><span class="line">        totalCost -&#x3D; node.cost</span><br><span class="line">        if node.next !&#x3D; nil &#123; node.next?.prev &#x3D; node.prev &#125;</span><br><span class="line">        if node.prev !&#x3D; nil &#123;node.prev?.next &#x3D; node.next&#125;</span><br><span class="line">        if head &#x3D;&#x3D; node &#123; head &#x3D; node.next &#125;</span><br><span class="line">        if tail &#x3D;&#x3D; node &#123; tail &#x3D; node.prev &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func removeTail() &#123;</span><br><span class="line">        guard let tailNode &#x3D; self.tail else &#123; return &#125;</span><br><span class="line">        dict.removeValue(forKey: tailNode.key)</span><br><span class="line">        totalCount -&#x3D; 1</span><br><span class="line">        totalCost -&#x3D; tailNode.cost</span><br><span class="line">        if head &#x3D;&#x3D; tail &#123;</span><br><span class="line">            head &#x3D; nil</span><br><span class="line">            tail &#x3D; nil</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tail &#x3D; tailNode.prev</span><br><span class="line">            tail?.next &#x3D; nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func removeAll() &#123;</span><br><span class="line">        totalCost &#x3D; 0</span><br><span class="line">        totalCount &#x3D; 0</span><br><span class="line">        head &#x3D; nil</span><br><span class="line">        tail &#x3D; nil</span><br><span class="line">        if !dict.isEmpty &#123;</span><br><span class="line">            dict.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>内存缓存的处理主要注意以下一些细节</p>
<ol>
<li>对CacheMap的处理，需要考虑多线程的场景</li>
<li>需要考虑低内存警告和进入后台，需要手动释放内存</li>
<li>需要定时释放内存，防止内存积累越来越多</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HZMemoryCache.swift</span></span><br><span class="line"><span class="comment">//  si_HZ_ios</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HZ on 2021/2/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HZMemoryCache</span>: <span class="title">NSObject</span>, <span class="title">HZCacheProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定value为Data类型</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">Data</span></span><br><span class="line">    <span class="comment">//总的缓存数量</span></span><br><span class="line">    <span class="keyword">var</span> totalCount: <span class="type">UInt</span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheMap.totalCount</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 总的占用内存大小</span></span><br><span class="line">    <span class="keyword">var</span> totalCost: <span class="type">UInt</span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheMap.totalCost</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 单例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> shared: <span class="type">HZMemoryCache</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> cache = <span class="type">HZMemoryCache</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">return</span> cache</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// cacheMap锁</span></span><br><span class="line">    <span class="keyword">var</span> lock: pthread_mutex_t = pthread_mutex_t.<span class="keyword">init</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// LRU数据结构</span></span><br><span class="line">    <span class="keyword">var</span> cacheMap: <span class="type">HZCacheMap</span> = <span class="type">HZCacheMap</span>.<span class="keyword">init</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 建立专用的线程</span></span><br><span class="line">    <span class="keyword">var</span> queue:<span class="type">DispatchQueue</span> = <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="type">String</span>.<span class="keyword">init</span>(describing: type(of: <span class="type">HZMemoryCache</span>.<span class="keyword">self</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 最大size数</span></span><br><span class="line">    <span class="keyword">var</span> costLimit: <span class="type">UInt</span> = <span class="type">UInt</span>.<span class="built_in">max</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 最大缓存个数</span></span><br><span class="line">    <span class="keyword">var</span> countLimit: <span class="type">UInt</span> = <span class="type">UInt</span>.<span class="built_in">max</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 缓存生命</span></span><br><span class="line">    <span class="keyword">var</span> ageLimit: <span class="type">TimeInterval</span> = <span class="type">Double</span>.greatestFiniteMagnitude</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 自动清理周期</span></span><br><span class="line">    <span class="keyword">var</span> autoClearTimeInterval: <span class="type">TimeInterval</span> = <span class="number">10.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(didReceiveLowMemoryWarning(<span class="number">_</span>:)), name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">UIApplicationDidReceiveMemoryWarning</span>, object: <span class="literal">nil</span>)</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(didReceiveLowMemoryWarning(<span class="number">_</span>:)), name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">UIApplicationDidEnterBackground</span>, object: <span class="literal">nil</span>)</span><br><span class="line">        autoTimeClear()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>, name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">UIApplicationDidReceiveMemoryWarning</span>, object: <span class="literal">nil</span>)</span><br><span class="line">        <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>, name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">UIApplicationDidEnterBackground</span>, object: <span class="literal">nil</span>)</span><br><span class="line">        cacheMap.removeAll()</span><br><span class="line">        pthread_mutex_destroy(&amp;lock)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceiveLowMemoryWarning</span><span class="params">(<span class="number">_</span> notification:Notification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.removeAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didEnterBackground</span><span class="params">(<span class="number">_</span> notification:Notification)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.removeAll()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 自动清理缓存递归</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">autoTimeClear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.global(qos: <span class="type">DispatchQoS</span>.<span class="type">QoSClass</span>.background).asyncAfter(deadline: .now() + autoClearTimeInterval) &#123;</span><br><span class="line">            <span class="keyword">self</span>.clearInBackground()</span><br><span class="line">            <span class="keyword">self</span>.autoTimeClear()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clearInBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.clear(<span class="keyword">self</span>.countLimit)</span><br><span class="line">            <span class="keyword">self</span>.clearCost(<span class="keyword">self</span>.costLimit)</span><br><span class="line">            <span class="keyword">self</span>.clear(<span class="keyword">self</span>.ageLimit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HZMemoryCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否包含某一个key</span></span><br><span class="line">    <span class="comment">/// - Parameter key: AnyHashable</span></span><br><span class="line">    <span class="comment">/// - Returns: 返回是否包含</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="number">_</span> key: AnyHashable)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> isContain = cacheMap.dict.<span class="built_in">contains</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> $<span class="number">0</span>.key == key</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isContain</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 获取key对应的value</span></span><br><span class="line">    <span class="comment">/// - Parameter key: AnyHashable</span></span><br><span class="line">    <span class="comment">/// - Returns: 返回的value为Data类型</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getCache</span><span class="params">(<span class="keyword">for</span> key: AnyHashable)</span></span> -&gt; <span class="type">Data?</span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> node = cacheMap.dict[key] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.time = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">        cacheMap.bringNodeToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value <span class="keyword">as</span>? <span class="type">Data</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 添加缓存</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - key: AnyHashable</span></span><br><span class="line">    <span class="comment">///   - value: Data</span></span><br><span class="line">    <span class="comment">///   - cost: UInt 占用空间大小</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setCache</span><span class="params">(<span class="number">_</span> key: AnyHashable, <span class="number">_</span> value: Data,<span class="number">_</span> cost: UInt)</span></span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> node = cacheMap.dict[key] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//添加新的Node</span></span><br><span class="line">            <span class="keyword">let</span> newNode = <span class="type">HZLinkedNode</span>.<span class="keyword">init</span>(key, value, cost, now)</span><br><span class="line">            cacheMap.insertHead(newNode)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经存在相关node，对node进行更新</span></span><br><span class="line">        cacheMap.totalCost -= node.cost</span><br><span class="line">        cacheMap.totalCost += cost</span><br><span class="line">        node.cost = cost</span><br><span class="line">        node.value = value</span><br><span class="line">        node.time = now</span><br><span class="line">        cacheMap.bringNodeToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 移除相关Key</span></span><br><span class="line">    <span class="comment">/// - Parameter key: AnyHashable</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> key: AnyHashable)</span></span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> node = cacheMap.dict[key] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        cacheMap.removeNode(node)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 移除所有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        &#125;</span><br><span class="line">        cacheMap.removeAll()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 根据设置的最大缓存数量来清理key</span></span><br><span class="line">    <span class="comment">/// - Parameter maxCount: UInt</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">(<span class="number">_</span> maxCount: UInt)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> maxCount == <span class="number">0</span> &#123;</span><br><span class="line">            removeAll()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> finish = <span class="literal">false</span></span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">if</span> maxCount == <span class="number">0</span> &#123;</span><br><span class="line">            cacheMap.removeAll()</span><br><span class="line">            finish = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> cacheMap.totalCount &lt;= maxCount &#123;</span><br><span class="line">            finish = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        <span class="keyword">if</span> finish &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> !finish &#123;</span><br><span class="line">            <span class="keyword">if</span> pthread_mutex_trylock(&amp;lock) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> cacheMap.totalCount &gt; maxCount &#123;</span><br><span class="line">                    cacheMap.removeTail()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    finish = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                pthread_mutex_unlock(&amp;lock)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                usleep(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clearCost</span><span class="params">(<span class="number">_</span> maxCost: UInt)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> finish = <span class="literal">false</span></span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">if</span> maxCost == <span class="number">0</span> &#123;</span><br><span class="line">            cacheMap.removeAll()</span><br><span class="line">            finish = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> cacheMap.totalCost &lt;= maxCost &#123;</span><br><span class="line">            finish = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        <span class="keyword">if</span> finish &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> !finish &#123;</span><br><span class="line">            <span class="keyword">if</span> pthread_mutex_trylock(&amp;lock) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> cacheMap.totalCost &gt; maxCost &#123;</span><br><span class="line">                    cacheMap.removeTail()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    finish = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                pthread_mutex_unlock(&amp;lock)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                usleep(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">(<span class="number">_</span> interval: TimeInterval)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> finish = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> now = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">        pthread_mutex_lock(&amp;lock)</span><br><span class="line">        <span class="keyword">if</span> interval &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            cacheMap.removeAll()</span><br><span class="line">            finish = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> cacheMap.tail == <span class="literal">nil</span> || (now - cacheMap.tail!.time) &lt;= interval &#123;</span><br><span class="line">            finish = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock)</span><br><span class="line">        <span class="keyword">if</span> finish &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> !finish &#123;</span><br><span class="line">            <span class="keyword">if</span> pthread_mutex_trylock(&amp;lock) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> t = cacheMap.tail,(now - t.time) &gt; interval &#123;</span><br><span class="line">                    cacheMap.removeTail()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    finish = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                pthread_mutex_unlock(&amp;lock)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                usleep(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  HZDiskCache.swift</span><br><span class="line">&#x2F;&#x2F;  si_HZ_ios</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Created by HZ on 2021&#x2F;2&#x2F;17.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">class HZDiskCache: NSObject, HZCacheProtocol &#123;</span><br><span class="line">    typealias Element &#x3D; Data</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 磁盘缓存总数</span><br><span class="line">    var totalCount: UInt &#123;</span><br><span class="line">        guard self.isValidFileDir(fileCacheDir),let filePath &#x3D; fileCacheDir?.path else &#123; return 0 &#125;</span><br><span class="line">        do &#123;</span><br><span class="line">            let files &#x3D; try FileManager.default.contentsOfDirectory(atPath: filePath)</span><br><span class="line">            return UInt(files.count)</span><br><span class="line">        &#125; catch  &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 磁盘缓存大小</span><br><span class="line">    var totalCost: UInt &#123;</span><br><span class="line">        guard self.isValidFileDir(fileCacheDir),let dirUrl &#x3D; fileCacheDir, let filePath &#x3D; fileCacheDir?.path else &#123; return 0 &#125;</span><br><span class="line">        do &#123;</span><br><span class="line">            let files &#x3D; try FileManager.default.contentsOfDirectory(atPath: filePath)</span><br><span class="line">            var fileSize: UInt &#x3D; 0</span><br><span class="line">            files.forEach &#123; (file) in</span><br><span class="line">                let fileUrl &#x3D; dirUrl.appendingPathComponent(file)</span><br><span class="line">                if let attributes &#x3D; try? FileManager.default.attributesOfItem(atPath: fileUrl.path) &#123;</span><br><span class="line">                    fileSize +&#x3D; (attributes[FileAttributeKey.size] as? UInt ?? 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return fileSize</span><br><span class="line">        &#125; catch  &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 缓存文件夹URL</span><br><span class="line">    var fileCacheDir: URL?</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 自定义线程队列</span><br><span class="line">    var queue:DispatchQueue &#x3D; DispatchQueue.init(label: String.init(describing: type(of: HZDiskCache.self)))</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 缓存Size阈值</span><br><span class="line">    var costLimit: UInt &#x3D; UInt.max</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 缓存数量阈值</span><br><span class="line">    var countLimit: UInt &#x3D; UInt.max</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 缓存存活阈值</span><br><span class="line">    var ageLimit: TimeInterval &#x3D; Double.greatestFiniteMagnitude</span><br><span class="line">    </span><br><span class="line">    init(_ directoryName:String) &#123;</span><br><span class="line">        if let cacheDir &#x3D; FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).last &#123;</span><br><span class="line">            let folder &#x3D; cacheDir.appendingPathComponent(directoryName)</span><br><span class="line">            let exist &#x3D; FileManager.default.fileExists(atPath: folder.path)</span><br><span class="line">            if !exist &#123;</span><br><span class="line">                try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true, attributes: nil)</span><br><span class="line">            &#125;</span><br><span class="line">            fileCacheDir &#x3D; folder</span><br><span class="line">        &#125;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 检查一个URL是否存在</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter dir: URL</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: Bool</span><br><span class="line">    func isValidFileDir(_ dir: URL?) -&gt; Bool &#123;</span><br><span class="line">        guard let currentDir &#x3D; dir,!currentDir.path.isEmpty else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        return FileManager.default.fileExists(atPath: currentDir.path)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 拼接fileName和fileCacheDir</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Parameter fileName: &lt;#fileName description#&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; - Returns: &lt;#description#&gt;</span><br><span class="line">    func createFileUrl(_ fileName:String) -&gt; URL? &#123;</span><br><span class="line">        let fileUrl &#x3D; fileCacheDir?.appendingPathComponent(fileName)</span><br><span class="line">        return fileUrl</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension HZDiskCache &#123;</span><br><span class="line">    </span><br><span class="line">    func contains(_ key: AnyHashable) -&gt; Bool &#123;</span><br><span class="line">        guard let fileUrl &#x3D; createFileUrl(key as? String ?? &quot;&quot;) else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        return FileManager.default.fileExists(atPath: fileUrl.path)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func getCache(for key: AnyHashable) -&gt; Data? &#123;</span><br><span class="line">        guard let fileUrl &#x3D; createFileUrl(key as? String ?? &quot;&quot;) else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        do &#123;</span><br><span class="line">            let dataString &#x3D; try String(contentsOf: fileUrl, encoding: .utf8)</span><br><span class="line">            let data &#x3D; dataString.data(using: .utf8)</span><br><span class="line">            return data</span><br><span class="line">        &#125; catch  &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setCache(_ key: AnyHashable, _ value: Data, _ cost: UInt) &#123;</span><br><span class="line">        guard let fileUrl &#x3D; createFileUrl(key as? String ?? &quot;&quot;) else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        do &#123;</span><br><span class="line">            let dataString &#x3D; String.init(data: value, encoding: .utf8)</span><br><span class="line">            try dataString?.write(to: fileUrl, atomically: true, encoding: .utf8)</span><br><span class="line">        &#125; catch let error &#123;</span><br><span class="line">            print(&quot;cache error &#x3D; \(error)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        if totalCost &gt; costLimit &#123;</span><br><span class="line">            queue.async &#123;</span><br><span class="line">                self.clear(self.costLimit)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if totalCost &gt; costLimit &#123;</span><br><span class="line">            queue.async &#123;</span><br><span class="line">                self.clearCost(self.costLimit)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            self.clear(self.ageLimit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func remove(_ key: AnyHashable) &#123;</span><br><span class="line">        guard let dir &#x3D; fileCacheDir, let keyString &#x3D; key as? String else &#123; return &#125;</span><br><span class="line">        let removePath &#x3D; dir.appendingPathComponent(keyString)</span><br><span class="line">        try? FileManager.default.removeItem(at: removePath)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func removeAll() &#123;</span><br><span class="line">        guard let dir &#x3D; fileCacheDir else &#123; return &#125;</span><br><span class="line">        guard let fileArray &#x3D; FileManager.default.subpaths(atPath: dir.path) else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        fileArray.forEach &#123; (itemPath) in</span><br><span class="line">            try? FileManager.default.removeItem(atPath: dir.path + &quot;&#x2F;\(itemPath)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension HZDiskCache &#123;</span><br><span class="line">    func clear(_ maxCount: UInt) &#123;</span><br><span class="line">        let count &#x3D; Int(maxCount - totalCount)</span><br><span class="line">        guard count &gt; 0 else &#123;return&#125;</span><br><span class="line">        if maxCount &#x3D;&#x3D; 0 &#123;</span><br><span class="line">            removeAll()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        guard let dir &#x3D; fileCacheDir else &#123;return&#125;</span><br><span class="line">        guard var fileArray &#x3D; FileManager.default.subpaths(atPath: dir.path),fileArray.count &gt;&#x3D; count else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for _ in 0..&lt;count &#123;</span><br><span class="line">            guard let fileName &#x3D; fileArray.popLast() else &#123;return&#125;</span><br><span class="line">            remove(fileName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func clearCost(_ maxCost: UInt) &#123;</span><br><span class="line">        guard totalCost &lt; maxCost else &#123; return &#125;</span><br><span class="line">        if maxCost &#x3D;&#x3D; 0 &#123;</span><br><span class="line">            removeAll()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        guard let dir &#x3D; fileCacheDir else &#123;return&#125;</span><br><span class="line">        guard var fileArray &#x3D; FileManager.default.subpaths(atPath: dir.path) else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        while let fileName &#x3D; fileArray.last,totalCost &lt; maxCost &#123;</span><br><span class="line">            remove(fileName)</span><br><span class="line">            fileArray.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func clear(_ interval: TimeInterval) &#123;</span><br><span class="line">        if interval &#x3D;&#x3D; 0 &#123;</span><br><span class="line">            removeAll()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        guard let dir &#x3D; fileCacheDir else &#123;return&#125;</span><br><span class="line">        do &#123;</span><br><span class="line">            let files &#x3D; try FileManager.default.contentsOfDirectory(atPath: dir.path)</span><br><span class="line">            files.forEach(&#123; (name) in</span><br><span class="line">                let fileUrl &#x3D; dir.appendingPathComponent(name)</span><br><span class="line">                if let attribute &#x3D; try? FileManager.default.attributesOfItem(atPath: fileUrl.path) &#123;</span><br><span class="line">                    guard let modifyDate &#x3D; attribute[FileAttributeKey.modificationDate] as? Date else &#123;</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                    if Date().timeIntervalSince1970 - modifyDate.timeIntervalSince1970 &gt; interval &#123;</span><br><span class="line">                        remove(name)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; catch  &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>磁盘缓存中主要注意的就是对<code>FileManager</code>的使用。</p>
<ol>
<li><code>FileManager.default.contentsOfDirectory(atPath: filePath)</code>获得某一个文件夹下的 文件名数组</li>
<li><code>let attributes = try? FileManager.default.attributesOfItem(atPath: fileUrl.path)</code>获得某一个文件的属性，比如size</li>
<li><code>let cacheDir = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).last</code>指向沙盒中的cache文件夹</li>
<li><code>let folder = cacheDir.appendingPathComponent(directoryName)</code>拼接路径</li>
<li><code>FileManager.default.fileExists(atPath: folder.path)</code>检查一个文件是否存在</li>
<li><code>try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true, attributes: nil)</code> 创建文件夹</li>
<li><code>try? FileManager.default.removeItem(at: removePath)</code>移除一个文件</li>
</ol>
<h2 id="缓存整体方案"><a href="#缓存整体方案" class="headerlink" title="缓存整体方案"></a>缓存整体方案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HZCacheManager.swift</span></span><br><span class="line"><span class="comment">//  si_HZ_ios</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HZ on 2021/2/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HZCacheManager</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内存缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> memoryCacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 磁盘缓存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> diskCacheSize = <span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 磁盘缓存时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> diskAge = <span class="type">UInt</span>.<span class="built_in">max</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内存缓存对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> memoryCache = <span class="type">HZMemoryCache</span>.shared</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 磁盘缓存对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> diskCache = <span class="type">HZDiskCache</span>.<span class="keyword">init</span>(<span class="string">&quot;HZ&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 缓存是否包含</span></span><br><span class="line">    <span class="comment">/// - Parameter key: String</span></span><br><span class="line">    <span class="comment">/// - Returns: Bool</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="number">_</span> key:String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="type">HZLog</span>.show(<span class="string">&quot;缓存&quot;</span>, <span class="string">&quot;是否包含key = \(key)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> memoryCache.<span class="built_in">contains</span>(key) || diskCache.<span class="built_in">contains</span>(key)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 设置缓存</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - key: String</span></span><br><span class="line">    <span class="comment">///   - value: Data</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setCache</span><span class="params">(<span class="number">_</span> key:String, <span class="number">_</span> value:Data)</span></span> &#123;</span><br><span class="line">        <span class="type">HZLog</span>.show(<span class="string">&quot;缓存&quot;</span>, <span class="string">&quot;添加key = \(key)&quot;</span>)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataString = <span class="type">String</span>.<span class="keyword">init</span>(data: value, encoding: .utf8) <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">        memoryCache.setCache(key, value, <span class="type">UInt</span>(dataString.<span class="built_in">count</span>))</span><br><span class="line">        diskCache.setCache(key, value, <span class="type">UInt</span>(dataString.<span class="built_in">count</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 获得缓存Data</span></span><br><span class="line">    <span class="comment">/// - Parameter key: String</span></span><br><span class="line">    <span class="comment">/// - Returns: Data?</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dataFor</span><span class="params">(<span class="number">_</span> key:String)</span></span> -&gt; <span class="type">Data?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> data = memoryCache.getCache(<span class="keyword">for</span>: key) &#123;</span><br><span class="line">            <span class="type">HZLog</span>.show(<span class="string">&quot;缓存&quot;</span>, <span class="string">&quot;内存命中&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> data = diskCache.getCache(<span class="keyword">for</span>: key) &#123;</span><br><span class="line">            memoryCache.setCache(key, data, <span class="type">UInt</span>(<span class="type">String</span>.<span class="keyword">init</span>(data: data, encoding: .utf8)?.<span class="built_in">count</span> ?? <span class="number">0</span>))</span><br><span class="line">            <span class="type">HZLog</span>.show(<span class="string">&quot;缓存&quot;</span>, <span class="string">&quot;磁盘命中&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 移除某一个key</span></span><br><span class="line">    <span class="comment">/// - Parameter key: String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> key:String)</span></span> &#123;</span><br><span class="line">        <span class="type">HZLog</span>.show(<span class="string">&quot;缓存&quot;</span>, <span class="string">&quot;移除key = \(key)&quot;</span>)</span><br><span class="line">        memoryCache.remove(key)</span><br><span class="line">        diskCache.remove(key)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 移除所有缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">HZLog</span>.show(<span class="string">&quot;缓存&quot;</span>, <span class="string">&quot;移除所有缓存&quot;</span>)</span><br><span class="line">        memoryCache.removeAll()</span><br><span class="line">        diskCache.removeAll()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-生产力工具" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/20/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/">快捷键系列</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2020/10/20/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/" class="article-date">
  <time datetime="2020-10-19T16:00:00.000Z" itemprop="datePublished">2020-10-20</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常用工具快捷键"><a href="#常用工具快捷键" class="headerlink" title="常用工具快捷键"></a>常用工具快捷键</h1><h2 id="ITerm"><a href="#ITerm" class="headerlink" title="ITerm"></a>ITerm</h2><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>command 族</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">command + t          新标签</span><br><span class="line">command + w          关闭标签</span><br><span class="line">command + num        切换到指定标签</span><br><span class="line">command + f          查找</span><br><span class="line">command + enter      切换全屏</span><br><span class="line">command + d          垂直分屏</span><br><span class="line">command + shift + d  水平分屏</span><br><span class="line">command + option + 方向键      切换分屏</span><br><span class="line">command + shift + h         查看剪贴板历史</span><br><span class="line">command + ;             查看命令历史 </span><br><span class="line">command + r               清除屏幕</span><br></pre></td></tr></table></figure>

<p>control 族</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">control + u         删除当前行</span><br><span class="line">control + a         跳到当前行头</span><br><span class="line">control + e         跳到当前行末</span><br><span class="line">control + f         向前移动光标</span><br><span class="line">control + b         向后移动光标</span><br><span class="line">control + p         前一条指令</span><br><span class="line">control + n         后一条指令</span><br><span class="line">control + d         删除光标处文字</span><br><span class="line">control + w         删除前一个单词 </span><br><span class="line">control + h         删除光标之前内容</span><br><span class="line">control + k         删除光标之后内容</span><br></pre></td></tr></table></figure>

<h2 id="Vim-常用快捷键"><a href="#Vim-常用快捷键" class="headerlink" title="Vim 常用快捷键"></a>Vim 常用快捷键</h2><p>命令行中的大杀器,掌握快捷键就是掌握效率</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般模式</span></span><br><span class="line">h,j,k,l 或者上下左右方向键         控制方向</span><br><span class="line">control + f                     向下翻页</span><br><span class="line">control + b                     向上翻页</span><br><span class="line"><span class="number">0</span>                               移动到本行最前</span><br><span class="line">shift + <span class="number">4</span>                       移动到本行最末</span><br><span class="line">shift + g                       移动到最后一行</span><br><span class="line">gg                              移动到第一行</span><br><span class="line">number + g                      移动到指定行</span><br><span class="line">number + enter                  往下移动n行</span><br><span class="line">w                               往后移动一个单词</span><br><span class="line">b                               往前移动一个单词</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相关字符串</span></span><br><span class="line">/word                           向下查找word</span><br><span class="line">?word                           向上查找word</span><br><span class="line">n                               重复前一个搜索动作</span><br><span class="line"><span class="type">N</span>                               逆向重复前一个搜索动作</span><br><span class="line">:n1,n2s/word1/word2/g           替换</span><br><span class="line">:<span class="number">1</span>,$s/word1/word2/g             从头到位替换word1</span><br><span class="line">:<span class="number">1</span>,$s/word1/word2/gc            替换需要comfirm</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">x                               向后删除一个字符</span><br><span class="line"><span class="type">X</span> 和 backspace                   向前删除一个字符</span><br><span class="line">number + x                      连续向后删除n个字符</span><br><span class="line">dd                              删除所在行</span><br><span class="line">number + dd                     删除包括所在行以下的n行</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制</span></span><br><span class="line">yy                              复制所在行</span><br><span class="line">number + yy                     复制所在行以下n行</span><br><span class="line">p                               粘贴复制的内容到所在行的下一行</span><br><span class="line"><span class="type">P</span>                               粘贴复制内容到所在行的上一行</span><br><span class="line"></span><br><span class="line"><span class="comment">//上一步下一步</span></span><br><span class="line">u                               复原前一个动作</span><br><span class="line">control + r                     执行前一个动作</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件读写</span></span><br><span class="line">:w                              保存文件</span><br><span class="line">:w!                             强制文件保存</span><br><span class="line">:q                  </span><br><span class="line">:q!</span><br><span class="line">:wq</span><br><span class="line"><span class="type">ZZ</span></span><br><span class="line">:w filename2                    另存为</span><br><span class="line">:n1,n2 w filename2              将n1,n2</span><br><span class="line">:r filename2                    将filename2中的文件读取到当前行的下一行</span><br><span class="line"> </span><br><span class="line"> :<span class="keyword">set</span> nu                        显示代码行</span><br><span class="line"> :<span class="keyword">set</span> nonu                      取消显示代码行</span><br></pre></td></tr></table></figure>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-iOS锁" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/09/iOS%E9%94%81/">iOS锁小记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2020/07/09/iOS%E9%94%81/" class="article-date">
  <time datetime="2020-07-08T16:00:00.000Z" itemprop="datePublished">2020-07-09</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS-锁"><a href="#iOS-锁" class="headerlink" title="iOS 锁"></a>iOS 锁</h1><h2 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h2><p>锁的本质是一种操作系统资源，是用来控制资源获取的方式。获得锁就是获得了资源的访问，失去锁就是失去了资源的访问。加锁的区域相当于结界，锁就是钥匙。</p>
<h2 id="为什么要锁"><a href="#为什么要锁" class="headerlink" title="为什么要锁"></a>为什么要锁</h2><p>计算机中关于线程安全方面最主要考虑的因素是不同的线程同一时间修改同一数据引起的。比如有一个int值为10.现在有5个线程分别想修改它为1，2，3，4，5那么最后这个int会被改成什么是不确定的。这样我们就失去了对这个数据的控制。所以我们谈线程安全最主要的目的就是让我们的输出可控。那么如何做到可控呢？就是保证从数据开始修改直到修改结束都不能被打扰。锁的用途便在这里。</p>
<h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>如果让我们保证数据从开始修改到修改结束都不能被打扰，只能被一个线程修改。那么其他线程只能等，怎么等是关键。<br>举个通俗的例子，约会等人的时候，有的人会走来走去踱步，反复看手机，确认时间。还有的人就坐在那里小憩，淡定安逸。</p>
<ol>
<li>一直走来走去反复看手机确认时间的人类似<strong>自旋锁</strong>。在还没获得资源的时候，一直循环是否锁已经被释放，可以去获得资源了。优点就是快，肯定比睡着等的人能快点看到约会对象。但是就是耗费能量，毕竟一直在循环着。这样忙等待的线程还有一个问题就是线程还是可以做别的事情，如果线程再上一把锁，那就有可能造成死锁了。</li>
<li>确认资源还不能活去就去睡的类似<strong>互斥锁</strong>。互斥锁会将线程处于等待的位置，让CPU帮别的，一旦资源的锁释放了，线程会被唤醒去调用资源。</li>
<li><strong>读写锁</strong>从线程的状态来看算是一种互斥锁。但因为不控制读取，控制写，也降低了使用成本。</li>
<li><strong>递归锁</strong>允许同一个线程反复加锁。非递归锁反复在一个线程上加会造成死锁。</li>
<li><strong>信号量</strong>gcd中信号量和锁有些区别，信号量可以控制获取资源的线程数。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>线程因为竞争资源而陷入到永久的等待状态，若无外力作用，无法解开。</p>
<h2 id="iOS中用到的锁"><a href="#iOS中用到的锁" class="headerlink" title="iOS中用到的锁"></a>iOS中用到的锁</h2><h4 id="Dispatch-semaphore"><a href="#Dispatch-semaphore" class="headerlink" title="Dispatch semaphore"></a>Dispatch semaphore</h4><p>gcd的信号量 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)semaphoreMethod &#123;</span><br><span class="line">    dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">         dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">             dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">             [[Seller shared]sellToCustoms];</span><br><span class="line">             dispatch_semaphore_signal(semaphore);</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch sync"></a>dispatch sync</h4><p>创建一个串行队列，在串行队列中添加任务，任务按照指定的顺序输出。不会出现抢占资源的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;hz&quot;, NULL);</span><br><span class="line"> for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        [[Seller shared]sellToCustoms];</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dispatch-Barrier"><a href="#Dispatch-Barrier" class="headerlink" title="Dispatch Barrier"></a>Dispatch Barrier</h4><p>作为阻塞线程的一种方法，利用<code>dispatch_barrier_sync</code>可以达到控制资源的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)barrierMethod &#123;</span><br><span class="line">      for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">          dispatch_barrier_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">              [[Seller shared]sellToCustoms];</span><br><span class="line">          &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized实际上是对pthread_metux递归锁的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)synchronizedMethod &#123;</span><br><span class="line">     for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">          dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">              @synchronized ([self class]) &#123;</span><br><span class="line">                  [[Seller shared]sellToCustoms];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="un-fair-lock"><a href="#un-fair-lock" class="headerlink" title="un_fair_lock"></a>un_fair_lock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)unfairLockMethod &#123;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">       dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">           os_unfair_lock_lock(&amp;self-&gt;_unfairLock);</span><br><span class="line">           [[Seller shared]sellToCustoms];</span><br><span class="line">           os_unfair_lock_unlock(&amp;self-&gt;_unfairLock);</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)nslockMethod &#123;</span><br><span class="line">&#x2F;&#x2F;    NSLock *lock &#x3D; [[NSLock alloc]init];</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">          dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">              [self.nslock lock];</span><br><span class="line">              [[Seller shared]sellToCustoms];</span><br><span class="line">              [self.nslock unlock];</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)pthreadMutexMethod &#123;</span><br><span class="line"></span><br><span class="line">    static pthread_mutex_t lock;</span><br><span class="line">    pthread_mutex_init(&amp;lock, NULL);</span><br><span class="line">    for(int i &#x3D; 0;i&lt;10;i++) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;lock);</span><br><span class="line">            [[Seller shared]sellToCustoms];</span><br><span class="line">            pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)conditionMethod &#123;</span><br><span class="line">    NSCondition *condition &#x3D; [[NSCondition alloc]init];</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 10 ;i++) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            [condition lock];</span><br><span class="line">            [[Seller shared]sellToCustoms];</span><br><span class="line">            [condition unlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>锁的由来是因为多线程，因为多线程能做到不同的线程同时取获取一个资源，对这个资源进行修改。这样数据就不可控了，所以才有线程安全这样的命题，也才有了锁。</li>
<li>锁是一种系统资源，让高层的应用在多线程下，安全的控制资源的分配。</li>
<li>锁有一些基本的操作,<code>lock</code> <code>unlock</code> 。在获取资源之前加锁，在获取资源之后解锁，产生一个临界区，区域中的操作会根据系统的分配来进行操作。同时也有<code>wait</code>，<code>signal</code>操作。<code>wait</code>类似于<code>lock</code>，<code>signal</code>类似<code>unlock</code></li>
<li>锁根据对线程的操作来分，有<strong>互斥锁</strong>和<strong>自旋锁</strong>。加互斥锁的线程会让线程挂起等待系统调度获得锁。而自旋锁会让线程处于busy-waiting的状态，线程不断的循环看是否获得了锁。</li>
<li>比较底层的自旋锁<code>OSSpinLock</code>,但是因为自旋锁的忙等待，容易产生死锁的问题。还是慎用为好。</li>
<li>互斥锁就比较多了，底层有<code>pthread_metux_t</code>,然后又有<code>NSLock</code>，<code>NSRecursiveLock</code>，<code>NSCondition</code>等。</li>
<li>gcd中有几种方式能做到锁的效果。首先是信号量，我觉得信号量是一种高级锁，因为可以设置有限资源的数量，而不是给若干个资源加上若干个锁。<code>dispatch_barrier_sync</code>栅栏方法可以做到不同线程按顺序访问枷锁资源。当然也可以gcd创建串行队列，然后同步添加方法。</li>
<li><strong>递归锁</strong>允许同一个线程反复加锁。一般的锁适用于不同线程之间，强行加在同一个线程中会出现死锁。<code>synchronized</code>是对<code>pthread_metux_t</code>封装的递归锁。使用方便。</li>
<li>在使用锁的时候要万分小心。因为使用不当容易造成死锁或者增加运算量。</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-触摸事件总结" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/">iOS 触摸事件总结</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2020/05/04/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-05-03T16:00:00.000Z" itemprop="datePublished">2020-05-04</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS-触摸事件总结"><a href="#iOS-触摸事件总结" class="headerlink" title="iOS 触摸事件总结"></a>iOS 触摸事件总结</h1><h2 id="系统触摸事件生成传递"><a href="#系统触摸事件生成传递" class="headerlink" title="系统触摸事件生成传递"></a>系统触摸事件生成传递</h2><ol>
<li>当手指触摸屏幕的时候,产生中断.IOKit.framework接受中断，并且封装成IOHIDEvent对象。</li>
<li>系统利用进程间通信将对象传递给SpringBoard.app,SpringBoard是iOS的系统app，主要就是iOS的桌面系统。它负责管理触摸事件的分发。</li>
<li>SpringBoard根据这个事件进行分发，当主页面是我们开发的app的时候，即分发给我们的app。IOKit -&gt; SpringBoard -&gt; OurApp 这里面的数据传递都是进程间通信IPC</li>
<li>app主线程的Runloop在不断循环中或者在睡眠中被唤醒处理系统的Source1事件，即开始响应这个事件。</li>
<li>Source1是系统消息，传递过来的IOHIDEvent将交由Source0处理。</li>
<li>source0中将IOHIDEvent转化成UIEvent，并且调用UIApplication中的sendEvent方法，确定谁是最佳响应者。<br>以上步骤就是一个手势生给我们app处理的具体步骤</li>
</ol>
<h2 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a>UITouch</h2><ol>
<li>一次触摸生成一个UITouch对象。多点触控生成多个UITouch对象</li>
<li>多个手指先后触摸，根据算法判断是一个手势的多次点击，还是不同的两个手势</li>
<li>每个Touch对象会存放一些信息，比如时间，位置，阶段等信息</li>
<li>当手指离开屏幕一定时间，touch结束，对象释放</li>
</ol>
<h2 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h2><p>在触摸时间生成的阶段我们可以看到，最终我们的app是要接受并且处理UIEvent对象的。一个触摸便是一个UIEvent，因为一个触摸事件可能是多点触摸，会包含若干个UITouch对象。</p>
<h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p>每个能响应事件的都是一个<code>UIResponder</code>对象，如<code>UIView</code>，<code>UIApplication</code>，<code>AppDelegate</code>，<code>UIViewController</code>。他们都可以处理事件<br><code>touchesBegin</code>,<code>touchMoved</code>,<code>touchCancelled</code>,<code>touchEnded</code></p>
<h2 id="寻找事件最佳响应者"><a href="#寻找事件最佳响应者" class="headerlink" title="寻找事件最佳响应者"></a>寻找事件最佳响应者</h2><p>当我们的app主线程Runloop调用Application的sendEvent的方法，已经走过了第一步事件的发送，第二部寻找最佳的事件响应者。<br>我们把app中的View想象成一个桌子上放着大大小小的千层饼。UIApplication就是桌面。Application想知道应该把事件交给哪个Responder对象处理，就要从千层饼的底层往上试。直到获得最终要去响应事件的对象。这个过程被称为hit test命中测试。</p>
<h4 id="hit-test"><a href="#hit-test" class="headerlink" title="hit test"></a>hit test</h4><p>hit test 既是响应的传递者，也是应答者。沿以下路径进行事件传递:Application -&gt; UIWindow -&gt; view -&gt; childView。主要做两件事</p>
<ol>
<li>本身是否可以响应事件？ userInterfaceEnabled = false不行，隐藏不行，alpha 小于0.01也不行。当然也需要在触控范围内</li>
<li>如果不能响应返回nil</li>
<li>如果能响应，没有子View传给自己，如果有则递归给子View进行hit test。</li>
</ol>
<h2 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h2><p>根据寻找最高优先级的响应者的逻辑，我们能得到从UIWindow 到 hit tested-view的过程获得整个链路的路径。如 UIWindow -&gt; UIViewController -&gt; UIView -&gt; UIView。这个最高优先级的响应者对这个事件有着绝对的控制权，可以决定是否独吞这个事件，也可以将这个事件往下传递。这个过程就是响应链。与寻找响应者是逆向的。我们这里要记住一点，最高优先级的响应者不一定会响应事件。</p>
<h4 id="响应者"><a href="#响应者" class="headerlink" title="响应者"></a>响应者</h4><p>响应者根据响应链的顺序来处理事件。而处理事件就是是否重写UIResponder中的方法。</p>
<ol>
<li>不重写。不响应事件，将事件传递给nextResponder</li>
<li>重写。不调用<code>super.touchBegin</code>。完全自己响应事件</li>
<li>重写。调用<code>super.touchBegin</code>，自己响应，也让nextResponder响应</li>
</ol>
<h2 id="复杂事件处理-UIResponder-UIControl-UIGesture-Recognizer"><a href="#复杂事件处理-UIResponder-UIControl-UIGesture-Recognizer" class="headerlink" title="复杂事件处理 UIResponder UIControl UIGesture Recognizer"></a>复杂事件处理 UIResponder UIControl UIGesture Recognizer</h2><ol>
<li>更高优先级的手势识别器。Window在将事件传递给hit tested-view之前会优先给手势识别器识别。如果能识别，就取消hit-tested view的事件响应。反之hit-tested view响应。</li>
<li>UIControl比父视图上的手势识别器有更高的优先级，同层级还是UIGesture Recognizer更高。原因是因为UIControl本质上还是UIResponder，只不过UIControl会阻止父视图上的手势识别器识别。当然这仅限于系统UIControl，自定义UIControl并无此作用。</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Code Review流程梳理" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/21/Code%20Review%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">Code Review流程梳理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2020/02/21/Code%20Review%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/" class="article-date">
  <time datetime="2020-02-20T16:00:00.000Z" itemprop="datePublished">2020-02-21</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Code-Review-流程梳理"><a href="#Code-Review-流程梳理" class="headerlink" title="Code Review 流程梳理"></a>Code Review 流程梳理</h1><h3 id="Code-Review-当前问题反馈"><a href="#Code-Review-当前问题反馈" class="headerlink" title="Code Review 当前问题反馈"></a>Code Review 当前问题反馈</h3><h4 id="时间的问题"><a href="#时间的问题" class="headerlink" title="时间的问题"></a>时间的问题</h4><p>小伙伴反馈时间是一个大问题。<br>我拿我个人举例子做直播13天总共4000行代码，做outfit列表页重构6天总共2000行代码。一天平均产出300多行。而由报告指出最佳的code reivew是一小时500行。也就是如果一个组4个人，一天就需要2-3个小时去review代码，这样的现实条件肯定是不允许的。</p>
<h4 id="review的时候没有目标"><a href="#review的时候没有目标" class="headerlink" title="review的时候没有目标"></a>review的时候没有目标</h4><p>小组开始review却没有任何目标，review到底要review哪些点。在时间紧张的情况下，有没有目标，review也就像无头苍蝇能找到几个可以修改的点就完事了。</p>
<h4 id="review之后没有改进"><a href="#review之后没有改进" class="headerlink" title="review之后没有改进"></a>review之后没有改进</h4><p>辛辛苦苦做了review也发现了一些问题，但是没有修改，又或者说到了测试阶段，已经不太方便做大的调整。review之后的东西并没有去修改review的意义也就不复存在了。</p>
<h2 id="问题对策"><a href="#问题对策" class="headerlink" title="问题对策"></a>问题对策</h2><h4 id="定制Code-Review的目标"><a href="#定制Code-Review的目标" class="headerlink" title="定制Code Review的目标"></a>定制Code Review的目标</h4><p>检查点表明了我们对代码有着怎样的要求。一般有以下方向可以作为Code Review的检查点。</p>
<table>
<thead>
<tr>
<th align="center">检查点</th>
<th align="center">检查点说明</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">代码风格</td>
<td align="center">每个公司都有每个公司的代码风格，可以采用成熟的方案，可严可松。</td>
<td align="center">目前在研究机器来审阅这一块</td>
</tr>
<tr>
<td align="center">可读性</td>
<td align="center">包括注释，文档，方法名等。易于理解即可</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">错误检查</td>
<td align="center">检查业务逻辑等有无漏洞</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">单元测试覆盖度</td>
<td align="center">单元测试跑得通，基本上错误检查就少了。</td>
<td align="center">目前这块是空白</td>
</tr>
<tr>
<td align="center">小框架</td>
<td align="center">检查小的业务逻辑中是否存在与当前不符合的。比如应该用快速加车但是没用。应该符合某个业务规范没有符合。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">大框架</td>
<td align="center">检查大的方向是否符合规范。比如规定用MVC，却因为自己喜好用了MVVM等。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h4><p>目前发现几款工具可以用来Code Review。</p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>工具用途</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Upsource</td>
<td>Jetbrain用来Code Review的工具</td>
<td>需要购买，还在研究中</td>
</tr>
<tr>
<td>SonarQube</td>
<td>专门的Code Review工具</td>
<td>安卓不需要购买，Swift OC代码需要购买，正在研究中</td>
</tr>
<tr>
<td>安卓代码检查插件</td>
<td>Android 自带的代码检查工具</td>
<td>-</td>
</tr>
<tr>
<td>App code</td>
<td>Code Inject</td>
<td>检查代码中的错误，代码风格，拼写等。</td>
</tr>
<tr>
<td>目前已经测试过App Code可用，但是需要付费，效果可以。安卓代码检查插件很多，李敏在研究。目前在部署SonarQube看看整体的Code Review效果</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="流程闭环"><a href="#流程闭环" class="headerlink" title="流程闭环"></a>流程闭环</h4><p>针对review过后代码没有及时修改的问题。我们将收集每个版本过后的报告，作出公示，方便大家查看。<br>可以督促修改互相帮助。<br>报告的样式</p>
<h4 id="定期的全员交流代码"><a href="#定期的全员交流代码" class="headerlink" title="定期的全员交流代码"></a>定期的全员交流代码</h4><p>Code Review是大家相互学习，相互进步的过程。一个人写代码是闭门造车。<br>每两周组织一次安卓/iOS的内部Code Review分享。拿一块业务让作者来描述编写思路，大家一起交流。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/">https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/</a></p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-MVC架构演进" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/04/MVC%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/">MVC MVP MVVM模式演进</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/12/04/MVC%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" class="article-date">
  <time datetime="2019-12-03T16:00:00.000Z" itemprop="datePublished">2019-12-04</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于MVC-MVP-MVVM模式演进"><a href="#关于MVC-MVP-MVVM模式演进" class="headerlink" title="关于MVC MVP MVVM模式演进"></a>关于MVC MVP MVVM模式演进</h1><h2 id="最原始的MVC"><a href="#最原始的MVC" class="headerlink" title="最原始的MVC"></a>最原始的MVC</h2><p>最原始的MVC是model负责数据 View负责视图 Controller负责接收View的改变<br><img src="https://i.imgur.com/xcuJKgC.jpg"><br>原始的MVC，Model，View，Controller3者之间相互配合。但是由于3个实体联系紧密，没办法分离。</p>
<h2 id="iOS的MVC"><a href="#iOS的MVC" class="headerlink" title="iOS的MVC"></a>iOS的MVC</h2><p><img src="https://i.imgur.com/Gsabxb4.jpg"><br>很长时间看白胡子老头的MVC我都诧异了，这跟原始的MVC不是一个东西。<br>如图所示iOS的MVC框架将Model，Controller，View分离。Controller可以更新模型，更新View。Model可以发出通知，View可以通过target-action代理等等返回。与原始MVC不同的是，Model和View是相互不交流的，一定程度上降低了耦合。<br><img src="https://i.imgur.com/mErjGPA.jpg"></p>
<p>这样的MVC看似没啥问题。我们思索几个问题</p>
<ol>
<li>UIViewController我们充当的是View还是Controller</li>
<li>业务逻辑在哪里做</li>
<li>视图在哪里做，在哪里控制</li>
<li>网络请求呢？<br>以上的答案可能都在UIViewController,其实iOS的MVC，Model是很简单的抽离了。但是View和Controller并没有分离，UIViewController是又当View又当Controller，既要管理Model，又要处理网络请求，更新视图，处理视图回调等等。</li>
</ol>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>既然UIViewController又当View又当Controller，我们试着将这个模块拆分。而ViewController是继承在UIView之下的，我们把视图模块保留给UIViewController，命名一个新的东西叫Presenter。<br><img src="https://i.imgur.com/fHm3pzB.jpg"><br>Presenter更新模型和视图。也接受模型和视图的事件。<br>这其实与苹果的MVC非常相似，但是我们不要忘记那个庞大的UIViewController可是要处理视图布局的。它没有办法与视图分离，而MVP将Presenter不会有任何对视图的布局。Presneter持有视图，更新视图而已。<br>用代码展示了一段MVP的架构。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HelloView</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HelloViewPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> view:<span class="type">HelloView</span>, <span class="number">_</span> person:<span class="type">Person</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showHello</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPresenter</span>:<span class="title">HelloViewPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> view:<span class="type">HelloView</span></span><br><span class="line">    <span class="keyword">let</span> model:<span class="type">Person</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> view: <span class="type">HelloView</span>, <span class="number">_</span> person: <span class="type">Person</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">        <span class="keyword">self</span>.model = person</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view.sayHello()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHelloView</span>:<span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> label:<span class="type">UILabel</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> button:<span class="type">UIButton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> button = <span class="type">UIButton</span>.<span class="keyword">init</span>(type: .system)</span><br><span class="line">        button.addTarget(<span class="keyword">self</span>, action: #selector(didClick(<span class="number">_</span>:)), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">        <span class="keyword">return</span> button</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> presenter:<span class="type">HelloViewPresenter?</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">didClick</span><span class="params">(<span class="number">_</span> sender:<span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">        presenter?.showHello()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(label)</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(button)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyHelloView</span>:<span class="title">HelloView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.label.text = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MVP在苹果的MVC上进一步的区分了三个模块之间的关系，而且明确了UIViewController的职责所在。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://i.imgur.com/ZZDJcOy.jpg"><br>MVVM与MVP十分相似，UIViewController承担View的角色。View和Model之间不存在紧耦合。<br>不一样的是MVP中Presenter处理view的更新方法。而MVVM通过数据绑定，让视图处理视图的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name:String</span><br><span class="line">    var age:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol HelloViewModelProtocol: class &#123;</span><br><span class="line">    var hello:String? &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    var helloStrDidChange:((HelloViewModelProtocol) -&gt; ())? &#123;get set&#125;</span><br><span class="line">    init(_ person:Person)</span><br><span class="line">    func sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloViewModel:HelloViewModelProtocol &#123;</span><br><span class="line">    var helloStrDidChange: ((HelloViewModelProtocol) -&gt; ())?</span><br><span class="line">    let person:Person</span><br><span class="line">    required init(_ person: Person) &#123;</span><br><span class="line">        self.person &#x3D; person</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @objc func sayHello() &#123;</span><br><span class="line">        self.hello &#x3D; &quot;hello \(Date.init().description)&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var hello:String? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            self.helloStrDidChange?(self)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHelloView:UIViewController &#123;</span><br><span class="line">    var label:UILabel &#x3D; &#123;</span><br><span class="line">        let label &#x3D; UILabel.init()</span><br><span class="line">        return label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lazy var button:UIButton &#x3D; &#123;</span><br><span class="line">        let button &#x3D; UIButton.init(type: .system)</span><br><span class="line">        button.addTarget(self.viewModel, action: #selector(HelloViewModel.sayHello), for: .touchUpInside)</span><br><span class="line">        return button</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    var viewModel:HelloViewModel? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            self.viewModel?.helloStrDidChange &#x3D; &#123; [weak self] vm in</span><br><span class="line">                self?.label.text &#x3D; vm.hello</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        self.view.addSubview(label)</span><br><span class="line">        self.view.addSubview(button)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let model &#x3D; Person.init(name: &quot;foo&quot;, age: &quot;12&quot;)</span><br><span class="line">let vm &#x3D; HelloViewModel.init(model)</span><br><span class="line">let vc &#x3D; MyHelloView.init()</span><br><span class="line">vc.viewModel &#x3D; vm</span><br></pre></td></tr></table></figure>
<p>同样的一个例子，与MVP中不同的是，ViewModel中并不添加额外的代码对View进行操作。<br>MVVM将MVP中对View的操作放回了视图。通过数据绑定可以更加方便的将view和controller进行分离。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里讨论的MVC是苹果的MVC，即苹果改进的MVC</p>
<ol>
<li>MVC MVP MVVM只是不断的职责分离不断地解耦地过程。</li>
<li>本质上MVC MVP MVVM只是叫法上的不同。Model一直代表的是数据层。V一直代表的是视图层。而C P VM是不同的职责划分对于控制逻辑这块不同的叫法。</li>
<li>MVC中，V和C相互有紧密的耦合，UIViewController职责不明。</li>
<li>MVP中，在MVC的基础上，把UIViewController的职责明确成View视图层。将其中Controller的部分用Presenter来承担，Presenter作为View和Model的媒介，即更新Model也更新View。</li>
<li>MVVM中 在MVP的基础上觉得Presenter中对视图的更新，应该让视图去做。加上响应式的编程方式，使得MVVM看起来特别优美。</li>
<li>MVC是经典的UI组织框架，用起来简单方便。</li>
<li>MVP，MVVM在MVC的基础上进行了改进。改进的优点是解耦，易测试。改进之后会让代码变得更多，有很多代码花费在数据绑定等操作上。而MVVM配合响应式的编程方式写得好会很优美，写不好会加大测试难度。</li>
<li>MVVM的创造者也说过MVVM在小型的UI场景中不适合，在大型的UI场景下，数据绑定又会很花时间，所以如何选择适合的框架还是看团队。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52</a><a target="_blank" rel="noopener" href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52</a>)</p>

      

      
        
    </div>
  </div>
  
</article>



  
    <article id="post-Instrument 使用技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/30/Instrument%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">Instrument 使用技巧</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2019/11/30/Instrument%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="article-date">
  <time datetime="2019-11-29T16:00:00.000Z" itemprop="datePublished">2019-11-30</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Instrument-使用技巧"><a href="#Instrument-使用技巧" class="headerlink" title="Instrument 使用技巧"></a>Instrument 使用技巧</h1><h2 id="对CPU性能进行追踪"><a href="#对CPU性能进行追踪" class="headerlink" title="对CPU性能进行追踪"></a>对CPU性能进行追踪</h2><p><img src="https://i.imgur.com/V55ZtzW.png" alt="WeChatWorkScreenshot_7cf7ac1c-55d4-47c7-bcc7-3299f7a8b332"></p>
<h2 id="Leaks"><a href="#Leaks" class="headerlink" title="Leaks"></a>Leaks</h2><p>对内存泄漏进行追踪。<br><img src="https://i.imgur.com/UtaAUjp.jpg" alt="-w299"><br>对于内存泄漏的追踪有3种维度。</p>
<ol>
<li><code>Leaks</code>具体泄漏的对象。</li>
<li><code>Cycles &amp; Roots</code>泄漏内存的对象关系</li>
<li><code>Call Tree</code>具体泄漏所在的方法<br>这三个我们能从不同维度对泄漏对象进行追踪。</li>
</ol>
<p>一般检查模式（debug模式需要DSYM文件，以便查看符号）</p>
<ol>
<li>查看<code>Call Tree</code> </li>
<li>在底部筛选<code>Call Tree</code>,去除系统方法。</li>
<li>底部<code>Call Tree Constraints</code>进行大小筛选。</li>
<li>底部<code>Data mining</code>可以对当前已经泄漏的对象进行数据分析。比如可以分析是哪个库产生的，去除一些杂数据，找到真正自己编码中国出问题的位置。</li>
<li>点击相应的内容，右侧可以查看具体的栈信息/或者记录信息<br><img src="https://i.imgur.com/Ekyttcn.png" alt="WeChatWorkScreenshot_e5d281ed-a221-4adc-a5a7-856f116ed422"></li>
</ol>
<h2 id="Timer-Profile"><a href="#Timer-Profile" class="headerlink" title="Timer Profile"></a>Timer Profile</h2><ol>
<li>查看每个方法的耗时.可以根据线程来看时常。可以看双核CPU中其中一个核心调用方法的耗时</li>
<li>可以查看App Life Cycle。<br><img src="https://i.imgur.com/qMLGlpD.jpg" alt="-w798"></li>
</ol>
<p><img src="https://i.imgur.com/GcdAGNz.jpg" alt="-w569"></p>
<h2 id="View-Debuging"><a href="#View-Debuging" class="headerlink" title="View Debuging"></a>View Debuging</h2><p>在真机调试图层的时候，我们选中Xcode任务栏中的<code>Debug</code>-&gt;<code>View Debugging</code>-&gt;<code>Rendering</code><br><img src="https://i.imgur.com/3sfoVwb.jpg" alt="-w240"></p>
<ol>
<li>Color Blended Layers.图层混合，红色为混合图层，绿色为没有使用混合图层。这个跟业务设计相关，能不混合就不混合。实在要混合，问题也不大。</li>
<li>Color Hits Green and Missed Red。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</li>
<li>Color Copied Images.如果GPU不支持这种图片格式，会交给CPU进行格式转化，标记为蓝色。</li>
<li>Color layer Formats. 区分不同的图片格式</li>
<li>Color Misaligned Images. 与布局不符合的展示相关颜色。</li>
<li>Color Offscreen-Rendered Yellow。离屏渲染展示黄色</li>
<li>Color Compositing Fast-Path Blue.有使用色彩合成快速通道的展示为蓝色。</li>
<li>Flash Updated Regions.展示刷新UI的区域</li>
</ol>

      

      
        
    </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/hejianxian" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2021 hulu 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a target="_blank" rel="noopener" href="https://github.com/hejianxian" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>